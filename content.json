[{"title":"手写rpc框架","date":"2022-06-09T05:01:35.000Z","path":"2022/06/09/study/手写rpc框架/","text":"使用Zookeeper作为注册中心，RMI作为连接技术，手写RPC框架。 1、创建RPCClient项目创建父项目RPCClient 包含三个子项目 pojo: service中需要的实体类 service：包含被serviceimpl和consumer依赖的接口。 serviceimpl:provider提供的服务内容 consumer：消费者，调用服务内容。 2、pojo项目在父项目下新建子项目pojo 该子项目包括一个文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com;import java.io.Serializable;/** * @Author: ly * @Date: 2022 - 06 - 08 - 21:04 * @Description: com * @Version: 1.0 */public class User implements Serializable &#123; private Integer id; private String name; public User() &#123; &#125; public User(Integer id, String name) &#123; this.id = id; this.name = name; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 3、service项目添加依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;pojo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 新建MyService接口，继承Remote类 12345678910111213141516171819package com.service;import com.User;import java.rmi.Remote;import java.rmi.RemoteException;import java.util.List;/** * @Author: ly * @Date: 2022 - 06 - 08 - 21:06 * @Description: com * @Version: 1.0 */public interface MyService extends Remote &#123; public List&lt;User&gt; findAll() throws RemoteException;&#125; 4、provider项目添加依赖 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 新建ProviderRun类 123456789101112131415161718192021222324252627282930313233343536373839404142package com;import com.service.Impl.MyServiceImpl;import com.service.MyService;import org.apache.zookeeper.*;import java.nio.charset.StandardCharsets;import java.rmi.Naming;import java.rmi.Remote;import java.rmi.registry.LocateRegistry;/** * @Author: ly * @Date: 2022 - 06 - 08 - 21:15 * @Description: com * @Version: 1.0 */public class ProviderRun &#123; public static void main(String[] args) &#123; try &#123; MyService service = new MyServiceImpl(); LocateRegistry.createRegistry(8989); String url = &quot;rmi://localhost:8989/myService&quot;; Naming.bind(url, service); System.out.println(&quot;MRI服务启动成功！&quot;); //创建zookeeper并发布信息 ZooKeeper zooKeeper = new ZooKeeper(&quot;192.168.253.132:2181&quot;, 10000, new Watcher() &#123; @Override public void process(WatchedEvent watchedEvent) &#123; System.out.println(&quot;获取链接&quot;); &#125; &#125;); //运行前确保/rpc目录存在 zooKeeper.create(&quot;/rpc/provider&quot;,url.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); System.out.println(&quot;注册成功&quot;); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 运行项目，打开zookeeper，查看是否写入到&#x2F;rpc&#x2F;provider 5、consume项目添加依赖 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建service接口 123456789101112131415package com.consumer.service;import com.User;import java.util.List;/** * @Author: ly * @Date: 2022 - 06 - 08 - 21:36 * @Description: com.consumer.service * @Version: 1.0 */public interface PageService &#123; public List&lt;User&gt; show();&#125; 创建其实现类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.consumer.service.Impl;import com.User;import com.consumer.service.PageService;import com.service.MyService;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.ZooKeeper;import org.springframework.stereotype.Service;import java.rmi.Naming;import java.util.List;/** * @Author: ly * @Date: 2022 - 06 - 08 - 21:37 * @Description: com.consumer.service.Impl * @Version: 1.0 */@Servicepublic class PageServiceImpl implements PageService &#123; @Override public List&lt;User&gt; show() &#123; try &#123; ZooKeeper zooKeeper = new ZooKeeper(&quot;192.168.253.132:2181&quot;, 10000, new Watcher() &#123; @Override public void process(WatchedEvent watchedEvent) &#123; System.out.println(&quot;链接成功&quot;); &#125; &#125;); byte[] bytes = zooKeeper.getData(&quot;/rpc/provider&quot;,false,null); MyService myService = (MyService) Naming.lookup(new String(bytes)); return myService.findAll(); &#125; catch (Exception e)&#123; e.printStackTrace(); return null; &#125; &#125;&#125; 创建控制器 12345678910111213141516171819202122232425262728package com.consumer.controller;import com.User;import com.consumer.service.PageService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @Author: ly * @Date: 2022 - 06 - 08 - 22:19 * @Description: com.consumer.controller * @Version: 1.0 */@RestControllerpublic class PageController &#123; @Autowired private PageService pageService; @RequestMapping(&quot;/show&quot;) public List&lt;User&gt; show() &#123; return pageService.show(); &#125;&#125; 启动springboot项目，输入localhost:8080&#x2F;show","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://lyblog2022.github.io/tags/zookeeper/"},{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"RPC","slug":"RPC","permalink":"https://lyblog2022.github.io/tags/RPC/"}]},{"title":"zookeeper使用","date":"2022-06-07T13:17:08.000Z","path":"2022/06/07/study/zookeeper使用/","text":"zookeeper内容发布及消息订阅 1、向zookeeper中注册内容新建项目ZookeeperClient 1.1 创建&#x2F;demo使用zookeeper的客户端命令工具创建&#x2F;demo 12./zkCli.shcreate /demos 1.2 添加依赖1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1.3 编写代码1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; try &#123; /** * 创建zookeeper对象 * 参数1：zookeeper IP+端口 * 参数2：访问超时设置 * 参数3：链接成功后，编写成功信息 */ String ip = &quot;192.168.253.132:2181&quot;; ZooKeeper zooKeeper = new ZooKeeper(ip, 10000, new Watcher() &#123; @Override public void process(WatchedEvent watchedEvent) &#123; System.out.println(&quot;获取链接&quot;); &#125; &#125;); /** * 向zookeeper发送内容 * 参数1：发送的文件 * 参数2：发送的内容 * 参数3：权限 * 参数4：内容的模式 */ String content = zooKeeper.create(&quot;/demo/rmi-adress&quot;,&quot;rmi:localhost:8080/demoService&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL); System.out.println(&quot;content=&quot;+content); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 1.4 控制台输出 1.5 zookeeper输出 1.6 异常 解决方案—-防火墙未关闭 查看防火墙状态 1systemctl status firewalld.service active表示当前防火墙处于开启状态 inactive表示关闭状态systemctl stop firewalld.service （关闭防火墙）systemctl start firewalld.service （开启防火墙）systemctl disable firewalld.service （禁止防火墙自启动）systemctl enable firewalld.service （防火墙随系统开启启动） 关闭防火墙即可 1.7 异常2—6.8新增如果在关闭防火墙后仍出现以上问题 解决方案–用记事本打开C:\\Windows\\System32\\drivers\\etc\\hosts文件，添加ZooKeeper部署的服务器ip，然后保存。 2、zookeeper消息订阅2.1 编写代码12345678910111213141516171819202122232425262728try &#123; /** * 创建zookeeper对象 * 参数1：zookeeper IP+端口 * 参数2：访问超时设置 * 参数3：链接成功后，编写成功信息 */ String ip = &quot;192.168.253.132:2181&quot;; ZooKeeper zooKeeper = new ZooKeeper(ip, 10000, new Watcher() &#123; @Override public void process(WatchedEvent watchedEvent) &#123; System.out.println(&quot;获取链接&quot;); &#125; &#125;); //从zookeeper中获取内容 //2.1获取节点 List&lt;String&gt; list = zooKeeper.getChildren(&quot;/demo&quot;,false); System.out.println(list); //获取内容 for(String child:list)&#123; byte[] result = zooKeeper.getData(&quot;/demo/&quot;+child,false,null); System.out.println(new String(result)); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; 2.2 控制台输出结果","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://lyblog2022.github.io/tags/zookeeper/"},{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"zookeeper常用命令","date":"2022-06-07T12:53:54.000Z","path":"2022/06/07/study/zookeeper/","text":"zookeeper常用命令 1、lsls -s&#x2F;path -s 详细信息，替代老版本ls2 -R 当前目录和子目录中内容都罗列出来 例如：ls -R &#x2F; 显示根目录下所有内容 2、createcreate &#x2F;path [data] [data] 包含内容 创建指定路径信息 例如：create &#x2F;demo 创建&#x2F;demo 3、getget [-s] &#x2F;path [-s] 详细信息 查看指定路径下内容。 例如： get -s &#x2F;demo null:存放的数据 cZxid:创建时zxid(znode每次改变时递增的事务id) ctime:创建时间戳 mZxid:最近一次更新的zxid mtime:最近一次更新的时间戳 pZxid:子节点的zxid cversion:子节点更新次数 dataversion:节点数据更新次数 aclVersion:节点ACL(授权信息)的更新次数 ephemeralOwner:如果该节点为ephemeral节点(临时，生命周期与session一样), ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是ephemeral节点, ephemeralOwner值为0. dataLength:节点数据字节数 numChildren:子节点数量 4、setset &#x2F;path data 设置节点内容 5、deletedelete &#x2F;path 删除节点","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://lyblog2022.github.io/tags/zookeeper/"},{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"CentOS 8 安装zookeeper","date":"2022-06-06T13:43:24.000Z","path":"2022/06/06/software/zookeeper/","text":"CentOS8安装zookeeper 1、检验java环境1java -version 2、安装wget,供文件下载时使用:1yum install wget 3、下载zookeeper1wget https://downloads.apache.org/zookeeper/zookeeper-3.8.0/apache-zookeeper-3.8.0-bin.tar.gz 4、解压，安装12345cd /usrmkdir zookeepercd ./zookeepertar -zxvf apache-zookeeper-3.8.0-bin.tar.gzmv apache-zookeeper-3.8.0-bin/ /usr/local/soft/ 这块我出现点问题，直接在跟目录下下载的，最好新建一个文件夹 5、创建数据和日志目录1234mkdir -p /data/zookeepermkdir -p /data/zookeeper/datamkdir -p /data/zookeeper/datalogsmkdir -p /data/zookeeper/logs ​ 说明： data:数据目录 datalogs:事务日志 logs:zk应用的日志 6、生成配置文件12cd /usr/local/soft/apache-zookeeper-3.8.0-bin/conf/cp zoo_sample.cfg zoo.cfg 7、设置配置文件1vi zoo.cfg 添加内容 123dataDir=/data/zookeeper/datadataLogDir=/data/zookeeper/datalogsadmin.enableServer=false ​ 说明： admin.enableServer&#x3D;false 用来关闭zk内置的web管理器 dataDir 定义了zk的数据目录 dataLogDir 定义了zk的事务日志 8、配置环境变量1vi /etc/profile 在末尾增加以下内容: 12export ZK_HOME=/usr/local/soft/apache-zookeeper-3.8.0-binexport PATH=$ZK_HOME/bin:$PATH 使环境变量生效: 1source /etc/profile 9、测试启动停止zookeeper12zkServer.sh startzkServer.sh stop","tags":[{"name":"software","slug":"software","permalink":"https://lyblog2022.github.io/tags/software/"},{"name":"CentOS 8","slug":"CentOS-8","permalink":"https://lyblog2022.github.io/tags/CentOS-8/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://lyblog2022.github.io/tags/zookeeper/"}]},{"title":"CentOS 8 配置JDK环境","date":"2022-06-06T13:41:00.000Z","path":"2022/06/06/software/jdk/","text":"CentOS 8 安装 JDK环境 1、使用Yum安装安装OpenJDK的可以选择此方法，方便快捷 1.1 查看是否有JDK环境1java -version 可以看到系统自带的 OpenJDK 版本信息，如果不满足，则卸载现有JDK 1.2 卸载现有JDK使用 rpm 命令查询 java 1rpm -qa | grep java .noarch文件可以不用管，卸载其余条目 执行一下命令卸载信息 1rpm -e --nodeps java-1.8.0-openjdk-1.8.0.201.b09-2.el8.x86_64 1rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.201.b09-2.el8.x86_64 卸载完后查询版本信息 1.3 使用Yum安装OpenJDK1yum install -y java-1.8.0-openjdk 1.3.1 报错 报错信息为： 12Failed to synchronize cache for repo &#x27;AppStream&#x27;, ignoring this repo.Failed to synchronize cache for repo &#x27;BaseOS&#x27;, ignoring this repo. 1.3.2 解决方案切换阿里源 1、备份 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2、下载新的 CentOS-Base.repo 到 &#x2F;etc&#x2F;yum.repos.d&#x2F; 1wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo 3、生成缓存 1yum makecache 1.4 校验 2、使用rpm包安装适用于有提供RPM Package的情况，例如Oracle JDK有提供。 Oracle JDK所有版本下载 OracleJDK8下载","tags":[{"name":"software","slug":"software","permalink":"https://lyblog2022.github.io/tags/software/"},{"name":"jdk","slug":"jdk","permalink":"https://lyblog2022.github.io/tags/jdk/"},{"name":"CentOS 8","slug":"CentOS-8","permalink":"https://lyblog2022.github.io/tags/CentOS-8/"}]},{"title":"RPC-远程服务调用","date":"2022-06-05T08:45:21.000Z","path":"2022/06/05/study/RPC/","text":"RPC–远程服务调用 1、RPC1.1 RFC​ RFC(Request For Comments) 是由互联网工程任务组(IETF)发布的文件集。文件集中每个文件都有自己唯一编号，例如：rfc1831。目前RFC文件由互联网协会(Internet Society，ISOC)赞助发型。 ​ RPC就收集到了rfc 1831中。可以通过下面网址查看： ​ https://datatracker.ietf.org/doc/rfc1831/ 1.2 RPC​ RPC在rfc 1831中收录 ，RPC（Remote Procedure Call） 远程过程调用协议 ​ RPC协议规定允许互联网中一台主机程序调用另一台主机程序，而程序员无需对这个交互过程进行编程。在RPC协议中强调当A程序调用B程序中功能或方法时，A是不知道B中方法具体实现的。 ​ RPC是上层协议，底层可以基于TCP协议，也可以基于HTTP协议。一般我们说RPC都是基于RPC的具体实现，如：Dubbo框架。从广义上讲只要是满足网络中进行通讯调用都统称为RPC，甚至HTTP协议都可以说是RPC的具体实现，但是具体分析看来RPC协议要比HTTP协议更加高效，基于RPC的框架功能更多。 ​ RPC协议是基于分布式架构而出现的，所以RPC在分布式项目中有着得天独厚的优势。 1.3 RPC和HTTP1.3.1 具体实现​ RPC：可以基于TCP协议，也可以基于HTTP协议。 ​ HTTP：基于HTTP协议 1.3.2 效率​ RPC：自定义具体实现可以减少很多无用的报文内容，使得报文体积更小。 ​ HTTP：如果是HTTP 1.1 报文中很多内容都是无用的。如果是HTTP2.0以后和RPC相差不大，比RPC少的可能就是一些服务治理等功能。 1.3.3 链接方式​ RPC：长连接支持。 ​ HTTP：每次连接都是3次握手。 1.3.4 性能​ RPC：可以基于很多序列化方式。如：thrift ​ HTTP：主要是通过JSON，序列化和反序列效率更低。 1.3.5 注册中心​ RPC ：一般RPC框架都带有注册中心。 ​ HTTP：都是直连。 1.3.6 负载均衡​ RPC：绝大多数RPC框架都带有负载均衡测量。 ​ HTTP：一般都需要借助第三方工具。如：nginx 1.3.7 综合结论​ RPC框架：一般都带有丰富的服务治理等功能，更适合企业内部接口调用。 ​ HTTP：更适合多平台之间相互调用。 2、HttpClient实现RPC2.1 HttpClient简介​ 在JDK中java.net包下提供了用户HTTP访问的基本功能，但是它缺少灵活性或许多应用所需要的功能。 ​ HttpClient起初是Apache Jakarta Common 的子项目。用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本。2007年成为顶级项目。 ​ 通俗解释：HttpClient可以实现使用Java代码完成标准HTTP请求及响应。 2.2 代码实现2.2.1 服务端1、新建控制器 com.controller.DemoController 12345678@Controllerpublic class DemoController &#123; @RequestMapping(&quot;/demo&quot;) @ResponseBody public String demo(String param)&#123; return &quot;demo&quot;+param; &#125;&#125; 2、启动器 com.HttpClientServerApplication 123456@SpringBootApplicationpublic class HttpClientServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpClientServerApplication.class,args); &#125;&#125; 2.2.2 客户端1、添加依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、新建类 新建com.HttpClientDemo，编写主方法。 ​ 1、使用Get方法访问 123456789101112131415161718192021222324public static void main(String[] args) &#123; try &#123; //创建http工具（理解成:浏览器） 发起请求，解析响应 CloseableHttpClient httpClient = HttpClients.createDefault(); //请求路径 URIBuilder uriBuilder = new URIBuilder(&quot;http://localhost:8080/demo&quot;); uriBuilder.addParameter(&quot;param&quot;, &quot;get123&quot;); //创建HttpGet请求对象 HttpGet get = new HttpGet(uriBuilder.build()); //创建响应对象 CloseableHttpResponse response = httpClient.execute(get); //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型，并设置字符编码 String result = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;); //输出结果 System.out.println(result); //释放资源 response.close(); httpClient.close(); &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; ​ 2、使用Post方式访问 12345678910111213141516171819202122232425262728public class HttpClientDemo &#123; public static void main(String[] args) &#123; try &#123; //创建http工具（理解成:浏览器） 发起请求，解析响应 CloseableHttpClient httpClient = HttpClients.createDefault(); //创建HttpPOST请求对象 HttpPost post = new HttpPost(&quot;http://localhost:8080/demo&quot;); //所有请求参数 List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;(); params.add(new BasicNameValuePair(&quot;param&quot;,&quot;123&quot;)); //创建HttpEntity接口的文本实现类的对象，放入参数并设置编码 HttpEntity httpEntity = new UrlEncodedFormEntity(params,&quot;utf-8&quot;); //放入到HttpPost对象中 post.setEntity(httpEntity); //创建响应对象 CloseableHttpResponse response = httpClient.execute(post); //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型 String result = EntityUtils.toString(response.getEntity()); //输出结果 System.out.println(result); //释放资源 response.close(); httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.3 Jackson用法2.3.1 对象 –&gt; json字符串123ObjectMapper objectMapper = new ObjectMapper();People peo = new People();objectMapper.writeValueAsString(peo); 2.3.2 json –&gt; 对象12ObjectMapper objectMapper = new ObjectMapper();People peo = objectMapper.readValue(content, People.class); 2.3.3 json –&gt; List集合123ObjectMapper objectMapper = new ObjectMapper();JavaType javaType = objectMapper.getTypeFactory().constructParametricType(List.class, People.class);List&lt;People&gt; list = objectMapper.readValue(content, javaType); 2.4 HttpClient请求包含JSON12345678910111213141516171819public class HttpClientDemo &#123; public static void main(String[] args) &#123; try &#123; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost post = new HttpPost(&quot;http://localhost:8080/demo&quot;); HttpEntity httpEntity= null;String json = &quot;&#123;&#125;&quot;; StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON); post.setEntity(entity); CloseableHttpResponse response = httpClient.execute(post); String result = EntityUtils.toString(response.getEntity()); System.out.println(result); response.close(); httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.5 控制器接口参数@RequestBody把请求体中流数据转换为指定的对象。多用在请求参数是json数据且请求的Content-Type&#x3D;”application&#x2F;json” 123456@RequestMapping(&quot;/demo4&quot;)@ResponseBodypublic String demo4(@RequestBody List&lt;People&gt; list) &#123; System.out.println(list); return list.toString();&#125; 2.6 Ajax发送json参数写法1234567891011121314var json = &#x27;[&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;ly&quot;&#125;,&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;ly123&quot;&#125;]&#x27;; $.ajax(&#123; url:&#x27;/demo5&#x27;, type:&#x27;post&#x27;, success:function(data)&#123; alert(data); for(var i = 0 ;i&lt;data.length;i++)&#123; alert(data[i].id +&quot; &quot;+data[i].name); &#125; &#125;, contentType:&#x27;application/json&#x27;,//请求体中内容类型 dataType:&#x27;json&#x27;,//响应内容类型。 data:json &#125;); 2.7 跨域跨域：协议、IP、端口中只要有一个不同的就是跨域请求 同源策略：浏览器默认只允许ajax访问同源（协议、IP、端口）内容 解决同源策略：在控制器接口上添加@CrossOrigin。表示允许跨域。本质在响应头中添加Access-Control-Allow-Origin: * 123456789101112131415var json = &#x27;[&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;ly&quot;&#125;,&#123;&quot;id&quot;:456,&quot;name&quot;:&quot;ly1234&quot;&#125;]&#x27;; $.ajax(&#123; url:&#x27;/demo5&#x27;, type:&#x27;post&#x27;, success:function(data)&#123; alert(data); for(var i = 0 ;i&lt;data.length;i++)&#123; alert(data[i].id +&quot; &quot;+data[i].name); &#125; &#125;, contentType:&#x27;application/json&#x27;,//请求体中内容类型 dataType:&#x27;json&#x27;,//响应内容类型。 data:json &#125;); 3、RMI实现RPC3.1 RMI简介 RMI(Remote Method Invocation) 远程方法调用。 RMI是从JDK1.2推出的功能，它可以实现在一个Java应用中可以像调用本地方法一样调用另一个服务器中Java应用（JVM）中的内容。 RMI 是Java语言的远程调用，无法实现跨语言。 3.2 执行流程 ​ Registry(注册表)是放置所有服务器对象的命名空间。 每次服务端创建一个对象时，它都会使用bind()或rebind()方法注册该对象。 这些是使用称为绑定名称的唯一名称注册的。 ​ 要调用远程对象，客户端需要该对象的引用。即通过服务端绑定的名称从注册表中获取对象(lookup()方法)。 3.3 API3.3.1 Remotejava.rmi.Remote 定义了此接口为远程调用接口。如果接口被外部调用，需要继承此接口。 3.3.2 RemoteException​ java.rmi.RemoteException ​ 继承了Remote接口的接口中，如果方法是允许被远程调用的，需要抛出此异常。 3.3.3 UnicastRemoteObject​ java.rmi.server.UnicastRemoteObject ​ 此类实现了Remote接口和Serializable接口。 ​ 自定义接口实现类除了实现自定义接口还需要继承此类。 3.3.4 LocateRegistry​ java.rmi.registry.LocateRegistry ​ 可以通过LocateRegistry在本机上创建Registry，通过特定的端口就可以访问这个Registry。 3.3.5 Naming​ java.rmi.Naming ​ Naming定义了发布内容可访问RMI名称。也是通过Naming获取到指定的远程方法。 3.4 代码实现3.4.1 服务端1、编写接口 com.service.DemoService 编写 123public interface DemoService extends Remote &#123; String demo(String demo) throws RemoteException;&#125; 2、编写实现类 com.service.impl.DemoServiceImpl 编写。 注意：构造方法是public的。默认生成protected 12345678public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123; public DemoServiceImpl() throws RemoteException &#123; &#125; @Override public String demo(String demo) throws RemoteException &#123; return demo+&quot;123&quot;; &#125;&#125; 3、主方法 编写com.DemoServer类，生成主方法 12345678public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123; public DemoServiceImpl() throws RemoteException &#123; &#125; @Override public String demo(String demo) throws RemoteException &#123; return demo+&quot;123&quot;; &#125;&#125; 4、运行项目 运行后项目，项目一直处于启动状态，表示可以远程访问此项目中的远程方法。 3.4.2 创建客户端代码1、复制服务端接口 把服务端com.service.DemoService粘贴到项目中 2、创建主方法 新建com.DemoClient 12345678public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123; public DemoServiceImpl() throws RemoteException &#123; &#125; @Override public String demo(String demo) throws RemoteException &#123; return demo+&quot;123&quot;; &#125;&#125;","tags":[{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"RPC","slug":"RPC","permalink":"https://lyblog2022.github.io/tags/RPC/"}]},{"title":"SpringBoot","date":"2022-06-05T07:02:13.000Z","path":"2022/06/05/study/SpringBoot/","text":"SpringBoot学习1 1、SpringBoot 1.1 简介 Spring Boot是Spring公司的一个顶级项目，和Spring Framework是一个级别的。 Spring Boot实际上是利用Spring Framework 4 自动配置特性完成。编写项目时不需要编写xml文件。发展到现在，Spring Boot已经具有很很大的生态圈，各种主流技术已经都提供了Spring Boot的启动器。 1.2 启动器​ Spring框架在项目中作用是Spring整合各种其他技术，让其他技术使用更加方便。Spring Boot的启动器实际上就是一个依赖。这个依赖中包含了整个这个技术的相关jar包，还包含了这个技术的自动配置，以前绝大多数XML配置都不需要配置了。当然了，启动器中自动配置无法实现所有内容的自动配置，在使用Spring Boot时还需要进行少量的配置（这个配置不是在xml中了，而是在properties或yml中即可）。如果是Spring自己封装的启动器的artifact id名字满足：spring-boot-starter-xxxx，如果是第三方公司提供的启动满足：xxxx-spring-boot-starter。以后每次使用Spring Boot整合其他技术时首先需要考虑导入启动器。 1.3 优点 使用Spring Boot可以创建独立的Spring应用程序 在Spring Boot中直接嵌入了Tomcat、Jetty、Undertow等Web 容器，在使用SpringBoot做Web开发时不需要部署WAR文件 通过提供自己的启动器(Starter)依赖，简化项目构建配置 尽量的自动配置Spring和第三方库 绝对没有代码生成，也不需要XML配置文件 1.4 核心起步依赖- 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 自动配置 -Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。","tags":[{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"springboot","slug":"springboot","permalink":"https://lyblog2022.github.io/tags/springboot/"}]},{"title":"SpringMVC","date":"2022-06-05T04:55:50.000Z","path":"2022/06/05/study/SpringMVC/","text":"Springmvc学习 1、SpringMVC1.1 概念 SpringMVC是spring为展现层提供的基于MVC设计理念的优秀WEB框架，是目前最主流的MVC框架之一 SpringMVC通过一套注解，可以让普通的JAVA类成为contrllor控制器，无需继承Servlet，实现了控制层和Servlet之间的解耦 SpringMVC支持Rest风格的URL写法 SpringMVC采用了松耦合，可热插的主键结构，比其他的框架更具扩展性和灵活性 1.2 执行流程 DispatcherServlet：前端控制器 用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器 HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlerMapping的实现类的作用：实现类RequestMappingHandlerMapping，它会处理@RequestMapping 注解，并将其注册到请求映射表中。 Handler：处理器 (自己定义的Controller处理单元) 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 HandlAdapter：处理器适配器 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行 HandlerAdapter的实现类的作用：实现类RequestMappingHandlerAdapter，则是处理请求的适配器，确定调用哪个类的哪个方法，并且构造方法参数，返回值。 View Resolver：视图解析器 View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 View：视图 SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开 发具体的页面。 2、 获取请求参数2.1 紧耦合方式​ DispatcherServlet中的service方法直接将此次请求的request对象传递给调用的单元方法即可。同时在单元方法上声明形参HttpServletRequest来接收request实参即可。 2.2 解耦合方式​ DispatcherServlet在其service方法中将请求数据根据需求从request对象中获取出来后，将数据直接传递给对应的单元方法使用。同时在单元方法上直接声明对应的形参接收请求数据即可。在单元方法上声明形参来接收请求数据时，形参名必须和请求数据的键名一致，DispatcherServlet会将调用单元方法的形参名作为请求数据的键名获取请求数据，然后传递给单元方法。 2.3 常见注解2.3.1 @RequestMapping 作用：用于建立请求 URL 和处理请求方法之间的对应关系 出现位置： 类上：请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以&#x2F;开头 方法上：请求 URL 的第二级访问目录 属性： value：用于指定请求的 URL。它和 path 属性的作用是一样的。 method：用于指定请求的方式。 2.3.2 @RequestParam 作用：把请求中指定名称的参数给控制器中的形参赋值。 属性： value：请求参数中的名称。 required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。 12345@RequestMapping(&quot;/getRequestParam&quot;) public String getRequestParam(@RequestParam(&quot;name&quot;) String uname, @RequestParam(value=&quot;age&quot;, required=false) Integer age) &#123; System.out.println(username+&quot;,&quot;+age); return &quot;success&quot;; &#125; 2.3.3 @PathVariable 作用：用于绑定 url 中的占位符。例如：请求 url 中 &#x2F;delete&#x2F;**{id}，这个{id}**就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。 属性： value：用于指定 url 中占位符名称。 required：是否必须提供占位符。 12345678910@Controllerpublic class PathController &#123; @RequestMapping(&quot;/testPathVariable/&#123;id&#125;/&#123;username&#125;&quot;) public String testPathVariable( @PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String username) &#123; System.out.println(&quot;id:&quot;+id); System.out.println(&quot;username:&quot;+username); System.out.println(&quot;testPathVariable1&quot;); return &quot;success&quot;; &#125;&#125; 3、作用域传参3.1 PageContext对象 作用域范围：当前jsp页面内有效 3.2 request对象 作用域范围：一次请求内。 作用: 解决了一次请求内的资源的数据共享问题 3.3 session对象 作用域范围：一次会话内有效。 说明：浏览器不关闭，并且后台的session不失效，在任意请求中都可以获取到同一个session对象。 作用：解决了一个用户不同请求的数据共享问题。 3.4 application(ServletContext)对象 作用域范围：整个项目内有效。 特点：一个项目只有一个，在服务器启动的时候即完成初始化创建无论如何获取都是同一个项目。 作用：解决了不同用户的数据共享问题。 4、拦截器Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。 要使用Spring MVC中的拦截器，就需要对拦截器类进行定义和配置。通常拦截器类可以通过两种方式来定义。 通过实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类（如HandlerInterceptorAdapter）来定义。 通过实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类来定义。 4.1 拦截器过滤器区别 拦截器SpringMVC的，而过滤器是servlet的。 拦截器不依赖与servlet容器，由spring容器初始化，过滤器依赖与servlet容器，由servlet容器初始化。 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。 拦截器可以获取IOC容器中的各个bean，而过滤器就不太方便，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。 4.2 preHandle方法 执行时机：再进入控制单元方法之前执行 调用：按拦截器定义顺序调用 具体作用：如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去 进行处理，则返回 true。 如果程序员决定不需要再调用其他的组件去处理请求，则返回 false。 参数： HttpServletRequest arg0，拦截的请求的request对象 HttpServletResponse arg1，拦截的请求的response对象 Object arg2 封存了单元方法对象的HandleMethod对象 123456789101112131415161718192021222324/** * * @param request 请求对象 * @param response 响应对象 * @param handler 目标要调用的Handler * @return 返回true放行,返回false拦截 * @throws Exception*/public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; /*在请求到达我们定义的handler之前工作的*/ System.out.println(&quot;MyInterceptor preHandle&quot;); /*设置请求和响应的乱码 */ /* request.setCharacterEncoding(&quot;UTF-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;);*/ // 判断是否登录 /*User user =(User) request.getSession().getAttribute(&quot;user&quot;); if(null == user) response.sendRedirect(&quot;index.jsp&quot;); return false;*/ // 用户权限控制 return true;&#125; 4.3 postHandle方法 执行时机：在进行数据处理和做出响应之间进行这个方法的调用 调用：在拦截器链内所有拦截器返成功调用 作用：在业务处理器处理完请求后，但是 DispatcherServlet 向客户端返回响应前被调用，在该方法中对用户请求 request域数据进行处理。 参数： HttpServletRequest arg0，拦截的请求的request对象 HttpServletResponse arg1，拦截的请求的response对象 Object arg2，封存了单元方法对象的HandleMethod对象 ModelAndView arg3，封存了单元方法的返回值资源路径和请求转到的Map数据 12345678910111213141516171819/** * * @param request * @param response * @param handler * @param modelAndView controller响应的结果,视图和数据 * @throws Exception */public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;MyInterceptor postHandle&quot;); /*控制数据*/ /*Map&lt;String, Object&gt; map = modelAndView.getModel(); String msg = (String)map.get(&quot;msg&quot;); String newMsg = msg.replaceAll(&quot;脏话&quot;, &quot;**&quot;); map.put(&quot;msg&quot;, newMsg);*/ /*控制视图*/ /*modelAndView.setViewName(&quot;/testDemo1.jsp&quot;);*/&#125; 4.4 afterCompletion方法 执行时机：在进行页面渲染的时候执行 调用：按拦截器定义逆序调用 作用：在DispatcherServlet 完全处理完请求后被调用,可以在该方法中进行一些资源清理的操作。 参数： HttpServletRequest arg0，拦截的请求的request对象 HttpServletResponse arg1，拦截的请求的response对象 Object arg2，封存了单元方法对象的HandleMethod对象 Exception arg3，存储了责任链的异常信息 1234567891011121314/** * 无论controller是否出现异常,都会执行的方法 * 一般来说都做一些资源释放工作 * @param request * @param response * @param handler * @param ex * @throws Exception */public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; /*页面渲染完毕,但是还没有给浏览器响应数据的时候*/ System.out.println(&quot;MyInterceptor afterCompletion&quot;); System.out.println(ex);&#125; 5、其他注解5.1 @PostMapping 作用：指定当前发送请求的方式只可以是post请求 属性：和@RequestMapping中属性一致 5.2 @GetMapping 作用：指定当前发送请求的方式只可以是get请求 属性：和@RequestMapping中属性一致 5.3 @JsonFormat 作用：处理响应json 数据的处理 属性： pattern ：指定响应时间日期的格式 Timezone：指定响应的时区，否则会有8个小时的时间差 5.4 @RequestBody 作用：用于获取请求体json格式的字符串内容。直接使用得到是 key=value&amp;key=value结构的数据，get 请求方式不适用。 属性：required：是否必须有请求体。默认值是:true。当取值为 true 时，get 请求方式会报错。如果取值 为 false，get 请求得到是null。 5.5 @CrossOrigin​ 跨域：出于浏览器的同源策略限制。同源策略（SameOriginPolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port） 作用：解决ajax请求之间的跨域问题 属性： origins：允许可访问的域列表IP maxAge：准备响应前的缓存持续的最大时间（以秒为单位）。 1234567@CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600)@RestController@RequestMapping(&quot;/account&quot;)public class AccountController &#123; @GetMapping(&quot;/&#123;id&#125;&quot;) public Account receive(@PathVariable Long id) &#123; &#125;&#125;","tags":[{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Springmvc","slug":"Springmvc","permalink":"https://lyblog2022.github.io/tags/Springmvc/"}]},{"title":"Spring","date":"2022-06-04T08:59:55.000Z","path":"2022/06/04/study/Spring/","text":"Spring学习 1、Spring框架1.1 Spring框架​ Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ​ —-百度百科 目的：解决企业应用开发的复杂性 功能：使用基本的JavaBean代替EJB，并提供更对的企业应用功能 范围：任何Java应用 ​ Spring是分层的全栈式的轻量级开发框架，以IOC和AOP为核心 1.2 优点 方便解耦，简化开发 Spring通过容器，将对象的创建从代码中剥离出来，交给Spring控制，避免直接编码造成模块之间的耦合度高，用户也不必自己编码处理对象的单例和多例控制，主要关注接口功能即可，不用关注具体使用哪个实现类和实现细节问题 AOP切面编程 AOP切面编程是程序设计的一种概念，Spring对该概念实现的比较好，通过切面编程我们可以在不修改原有代码的情况下实现功能的增加，通常用于事务控制、日志记录、性能检测、权限控制等等 声明式事务 事务的控制可以托管给Spring，我们通过注解或者配置文件声明事务的处理方式即可，不用我们自己去编码处理 整合JUNIT，方便测试 spring整合JUNIT单元测试，对于项目的功能都可以进行轻松快速的测试，便于我们调试程序 方便整合各种优秀的框架 丰富的功能封装 spring对JAVAEE(JDBC ，JAVAMail)都进行了一系列的封装，简化我们对于API的使用，提高程序的开发效率 规范的源码学习样本 spring的源码设计巧妙，结构清晰，大量使用了设计模式，是java代码规范编写的典范 2、Spring模块 2.1 Data Access/Integration（数据访问／集成）数据访问&#x2F;集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块 JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。 ORM 模块：对流行的对象关系映射 API，包括 JPA、JDO、Hibernate和 iBatis 提供了的集成层。 OXM 模块：提供了一个支持对象XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。 JMS 模块：指JAVA消息服务，包含的功能为生产和消费的信息。 Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。 2.2 Web 模块Spring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件 Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。 Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web应用程序。 Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。 Portlet 模块：提供了在 Portlet 环境中使用 MVC实现，类似 Web-Servlet 模块的功能。 2.3 Core Container（核心容器）Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成 Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。 Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。 Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。 Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。 2.4 其他模块Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块 AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。 Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。 Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。 Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。 3、Spring_IOC3.1 控制反转​ 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫依赖查找（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。–【百度】 ​ 简单来说，创建对象的权利，或者是控制的位置，由Java代码转移到Spring容器，由Spring的容器控制对象的创建，就是控制反转，Spring创建对象时，会读取配置文件中的信息，然后使用反射创建好的对象之后在容器中存储起来，当需要某个对象时，通过id获取对象即可，不需要自己去new 3.2 原理分析3.2.1 XML解析1&lt;bean id=&quot;stuDao&quot; class=&quot;com.dao.impl.StuDaoImpl&quot;&gt;&lt;/bean&gt; ​ 将上面的信息读取进入程序 对象的ID ,一个是对象的类的全路径名 3.2.2 反射123456//获得类的字节码Class clazz =Class.forName(&quot;com.dao.impl.StuDaoImpl&quot;);//通过字节码实例化对象Object obj = clazz.newInstance(); //将对象放到一个map集合中map.put(&quot;empDao&quot;,obj) 3.2.3 工厂模式1234public Object getBean(String name)&#123; Object obj =map.get(name); return obj; &#125; IOC接口 BeanFactory 接口：IOC容器基本功能接口，是spring内部使用的接口，我们在处理业务时一般不直接使用该接口 ApplicationContext 接口：BeanFactory的子接口，提供更多更强大的功能，研发人员一般使用的接口 4、Spring_XML方式实现DIspring中的Bean的管理: Bean(汉译咖啡豆)，又称JAVABean，其实就是JAVA程序程序中的一个个对象，所以Bean的管理其实就是spring对于JAVA程序中的对象的管理 管理的内容 对象的创建（IOC）：控制反转，就是Spring给我们创建对象，然后我们直接用，不用自己NEW 属性的赋值（DI）：依赖注入，即创建属性时给对象属性赋值，对象功能的实现往往要依赖属性的值，由于对象属性不仅仅是基本数据类型，还可能是其他类或者引用类型，那么依赖注入将会把更多的对象之间的关系整理到一起，可以形成一个庞大的依赖关系，DI处理的是对象的属性赋值和互相依赖的关系 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--通过无参构造方法构造对象--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.bean.User&quot; name=&quot;user1&quot; scope=&quot;prototype&quot; lazy-init=&quot;true&quot;&gt;&lt;/bean&gt;&lt;!--id:对象的idclass:类的全路径名name:和id类似,一般不用scope：控制对象单例多例和使用范围 singleton：作用域(scope 默认值), Spring IOC容器中只会存在一个共享的bean实例 prototype：作用域部署的bean，每一次获取都会产生一个新的bean实例，相当与一个new的操作 request：表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 session：作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效 global session：作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义lazy-init：懒加载 调用getBean的时候再去实例化对象--&gt;&lt;!--通过set方法给对象属性赋值--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.bean.User&quot;&gt; &lt;property name=&quot;userid&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;abcdefg&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--通过有参构造给对象属性赋值--&gt;&lt;bean id=&quot;user2&quot; class=&quot;com.bean.User&quot;&gt; &lt;constructor-arg name=&quot;userid&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;小明&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;password&quot; value=&quot;123456789&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--特殊符号--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.bean.User&quot;&gt; &lt;!--null值--&gt; &lt;property name=&quot;userid&quot;&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;!--特殊符号 转译字符 &lt; &amp;lt; &gt;&amp;gt; &amp; &amp;amp; --&gt; &lt;property name=&quot;username&quot; value=&quot;&amp;amp;xiaoming&amp;lt;&amp;gt;&quot;&gt;&lt;/property&gt; &lt;!-- 特殊符号 &lt;![CDATA[内容]]&gt; --&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;&lt;![CDATA[&amp;&lt;123456&gt;]]&gt;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 5、Spring_Bean生命周期 通过构造器创建bean实例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行构造器 为bean属性赋值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行set方法 初始化bean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 调用bean的初始化方法,需要配置指定调用的方法 bean的获取&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 容器对象 getBean方法 容器关闭销毁bean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 调用销毁方法,需要配置指定调用的方法 6、Spring注解方式管理Bean6.1 注解方式创建对象IOC @Component：放在类上,用于标记，告诉spring当前类需要由容器实例化bean并放入容器中 @Controller：@Component子注解，用于实例化controller层bean @Service：@Component子注解，用于实例化service层bean @Repository：@Component子注解，用于实例化持久层bean 6.2 注解方式依赖注入DI @Autowired：根据属性数据类型自动装配 @Qualifier：根据属性名称注入依赖 @Resources：可以根据类型,也可以根据名称注入 @Value：注入普通数据类型(8+String) 7、Spring代理7.1 代理模式通过代理对象访问目标对象，可以在目标对象基础上增强额外的功能，如添加权限、访问控制等 7.2 静态代理​ 静态代理中代理类与被代理类都需要实现同一个接口，即一个静态代理类只能代理一个类，并且需要知道要代理哪个类才能编写代理类代码，如果有其他类想要使用代理类，就必须再写一个 ​ 在实际开发中是可能有非常多的类需要被代理，并且可能并不知道要代理哪个类，所以继续使用静态代理反而会增加更多的工作量，且效率低下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.test;/*** @Author: Ly* @Description: */public class Test1 &#123; public static void main(String[] args) &#123; Person person =new Person(&quot;张三&quot;); Court court=new Lawyer(person); court.doCourt(); &#125;&#125;// 接口interface Court&#123; void doCourt();&#125;// 代理类class Lawyer implements Court&#123; private Person person; public Lawyer(Person person) &#123; this.person = person; &#125; @Override public void doCourt() &#123; System.out.println(&quot;律师取证:视频证明张三当时正在旅游,不在案发现场&quot;); System.out.println(&quot;律师总结:张三不可能去杀人&quot;); person.doCourt(); &#125;&#125;// 被代理的类class Person implements Court&#123; private String name; public Person(String name) &#123; this.name = name; &#125; @Override public void doCourt() &#123; System.out.println(name+&quot;说:我没有杀人&quot;); &#125;&#125; 7.3 动态代理​ 动态代理可以针对于一些不特定的类或者一些不特定的方法进行代理，可以在程序运行时动态的改变代理的规则，代理类在程序运行时才创建的代理模式，在这种情况下，代理类并不是在Java代码中定义好，而是在程序运行时根据在Java代码中的指示动态生成的 Proxy动态代理：JDK动态代理，面向接口 cglib动态代理：第三方动态代理，面向父类 7.3.1 Proxy动态代理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.testProxy; import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/** * @Author: Ly * @Description: */public class Test1 &#123; public static void main(String[] args) &#123; Dinner dinner=new Person(&quot;张三&quot;); // 通过Porxy动态代理获得一个代理对象,在代理对象中,对某个方法进行增强 // ClassLoader loader,被代理的对象的类加载器 ClassLoader classLoader = dinner.getClass().getClassLoader(); // Class&lt;?&gt;[] interfaces,被代理对象所实现的所有接口 Class[] interaces= dinner.getClass().getInterfaces(); //InvocationHandler h,执行处理器对象,专门用于定义增强的规则 InvocationHandler handler = new InvocationHandler() &#123; // invoke 当我们让代理对象调用任何方法时,都会触发invoke方法的执行 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //Object proxy, 代理对象 //Method method,被代理的方法 //Object[] args,被代理方法运行时的实参 Object res = null; if (method.getName().equals(&quot;eat&quot;)) &#123; System.out.println(&quot;饭前洗手&quot;); // 让原有的eat的方法去运行 res = method.invoke(dinner, args); System.out.println(&quot;饭后刷碗&quot;); &#125; else &#123; // 如果是其他方法,那么正常执行就可以了 res = method.invoke(dinner, args); &#125; return res; &#125; &#125;; Dinner dinnerProxy =(Dinner) Proxy.newProxyInstance(classLoader,interaces,handler); //dinnerProxy.eat(&quot;包子&quot;); dinnerProxy.drink(); &#125;&#125;interface Dinner&#123; void eat(String foodName); void drink();&#125; class Person implements Dinner&#123; private String name; public Person(String name) &#123; this.name = name; &#125; @Override public void eat(String foodName) &#123; System.out.println(name+&quot;正在吃&quot;+foodName); &#125; @Override public void drink() &#123; System.out.println(name+&quot;正在喝茶&quot;); &#125;&#125; class Student implements Dinner&#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void eat(String foodName) &#123; System.out.println(name+&quot;正在食堂吃&quot;+foodName); &#125; @Override public void drink() &#123; System.out.println(name+&quot;正在喝可乐&quot;); &#125;&#125; ​ 总结： 在不修改原有代码的或者没有办法修改原有代码的情况下，增强对象功能使用代理对象代替原来的对象去完成功能，进而达到拓展功能的目的 JDK Proxy动态代理是面向接口的动态代理，一定要有接口和实现类，代理对象增强的是实现类，在实现接口的方法重写方法，生成的代理对象只能转换成接口，不能转换成代理类 生成的代理对象只能转换成接口，不能转换成被代理类 代理对象只能增强接口中定义的方法，实现类中其他和接口无关的方法是无法增强的 代理对象只能读取到接口中方法上的注解，不能读取到实现类方法上的注解 7.3.2 cglib动态代理模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.testCglib; import org.junit.Test;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy; import java.lang.reflect.Method;/** * @Author: Ly * @Description: */public class Test1 &#123; @Test public void testCglib()&#123; Person person = new Person(); // 获取一个Person的代理对象 // 1 获得一个Enhancer对象 Enhancer enhancer = new Enhancer(); // 2 设置父类字节码 enhancer.setSuperclass(person.getClass()); // 3 获取MethodIntercepter对象 用于定义增强规则 MethodInterceptor methodInterceptor = new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; /* Object o, 生成之后的代理对象 personProxy Method method, 父类中原本要执行的方法 Person&gt;&gt;&gt; eat() Object[] objects, 方法在调用时传入的实参数组 MethodProxy methodProxy 子类中重写父类的方法 personProxy &gt;&gt;&gt; eat() */ Object res = null; if (method.getName().equals(&quot;eat&quot;)) &#123; // 如果是eat方法 则增强并运行 System.out.println(&quot;饭前洗手&quot;); res = methodProxy.invokeSuper(o,objects); System.out.println(&quot;饭后刷碗&quot;); &#125; else &#123; // 如果是其他方法 不增强运行 res = methodProxy.invokeSuper(o,objects); // 子类对象方法在执行,默认会调用父类对应被重写的方法 &#125; return res; &#125; &#125;; // 4 设置methodInterceptor enhancer.setCallback(methodInterceptor); // 5 获得代理对象 Person personProxy = (Person)enhancer.create(); // 6 使用代理对象完成功能 personProxy.eat(&quot;包子&quot;); &#125;&#125;class Person &#123; public Person() &#123; &#125; public void eat(String foodName) &#123; System.out.println(&quot;张三正在吃&quot;+foodName); &#125;&#125; 8、Spring AOP8.1 AOP 概念及原理​ 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。—-【百度百科】 ​ AOP 面向切面编程一般可以在不修改现有代码的情况下，对程序功能进行拓展，往往用于实现日志处理、权限控制、性能检测、事务控制等 ​ AOP实现的原理就是动态代理，在有接口的情况下，使用**JDK动态代理，在没有接口的情况下使用cglib动态代理** 8.2 术语 连接点（Joint point）：类里面可以被增强的方法，这些方法称之为连接点，表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等待，它自身还可以嵌套其他Join point 切入点（Pointcut）：实际被增强的方法，称之为切入点，表示一组joint point，这些joint point或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的Advince将要发生的地方 通知（Advince）：实际增强的逻辑部分称为通知（增加的功能），Advince定义了在Pointcut里面定义的程序点具体要做的操作，它通过before、after、around来区别是在每个joint point之前、之后还是代替执行的代码，通知类型：前置通知、后置通知、环绕通知、异常通知、最终通知 目标对象（Target）：被增强功能的对象（被代理的对象） 切面（Aspect）：表现为功能相关的一些advice放在一起声明成为一个java类，aspect声明类似与java的类声明，在aspect中会包含一些pointcut以及相应的advince 织入（Weaving）：创建代理对象并实现功能增强的声明并运行的过程，将Aspect和其他对象链接起来，并创建Advince Object的过程 8.3 注解方式实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.aspect; import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import java.util.Arrays;/** * @Author: Ly * @Description: */ @Component@Aspectpublic class DaoAspect &#123; //定义公共切点 @Pointcut(&quot;execution(* com.dao.*.add*(..))&quot;) public void addPointCut() &#123;&#125;. /* * 前置通知: 切点方法执行之前先执行的功能 * 参数列表可以用JoinPoint接收切点对象 * 可以获取方法执行的参数 * */ @Before(&quot;addPointCut()&quot;) public void methodBefore(JoinPoint joinPoint) &#123; System.out.println(&quot;Before invoked&quot;); &#125; /* * 后置通知:方法执行之后要增强的功能 * 无论切点方法是否出现异常都会执行的方法 * 参数列表可以用JoinPoint接收切点对象 * */ @After(&quot;addPointCut()&quot;) public void methodAfter(JoinPoint joinPoint) &#123; System.out.println(&quot;After invoked&quot;); &#125; /* * 返回通知:切点方法正常运行结束后增强的功能 * 如果方法运行过程中出现异常,则该功能不运行 * 参数列表可以用 JoinPoint joinPoint接收切点对象 * 可以用Object res接收方法返回值,需要用returning指定返回值名称 * */ @AfterReturning( value = &quot;addPointCut()&quot;,returning = &quot;res&quot;) public void methodAfterReturning(JoinPoint joinPoint, Object res) &#123; System.out.println(&quot;AfterReturning invoked&quot;); &#125; /* * 异常通知:切点方法出现异常时运行的增强功能 * 如果方法运行没有出现异常,则该功能不运行 * 参数列表可以用Exception ex接收异常对象 需要通过throwing指定异常名称 * */ @AfterThrowing( value = &quot;addPointCut()&quot;,throwing = &quot;ex&quot;) public void methodAfterThrowing(Exception ex) &#123; System.out.println(&quot;AfterThrowing invoked&quot;); &#125; /*环绕通知:在切点方法之前和之后都进行功能的增强 * 需要在通知中定义方法执行的位置,并在执行位置之前和之后自定义增强的功能 * 方法列表可以通过ProceedingJoinPoint获取执行的切点 * 通过proceedingJoinPoint.proceed()方法控制切点方法的执行位置 * proceedingJoinPoint.proceed()方法会将切点方法的返回值获取到,并交给我们,可以做后续处理 * 我们在环绕通知的最后需要将切点方法的返回值继续向上返回,否则切点方法在执行时接收不到返回值 * */ @Around(&quot;addPointCut()&quot;) public Object methodAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;aroundA invoked&quot;); Object proceed = proceedingJoinPoint.proceed(); System.out.println(&quot;aroundB invoked&quot;); return proceed; &#125;&#125; ​ 有多个增强类对同一个方法进行增强，通过@Order注解设置增强类优先级，数字越小，优先级越高，数字越小，其代理位置越靠近注入位置 9、Spring 事务9.1 事务​ 事务（Transaction）：指的是一个操作序列，该操作序列中的多个操作，只能都做，或者都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理 ​ 但并不是所有的操作序列都可以称为为事务，因为一个操作序列成为事务，必须满足事务的四个特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ACID特性 9.1.1 原子性​ 原子是自然界最小的颗粒，具有不可再分的特性。事务中的所有操作可以看做一个原子，事务是应用中不可再分的最小的逻辑执行体。 ​ 使用事务对数据进行修改的操作序列，要么全部执行，要么全不执行。通常，某个事务中的操作都具有共同的目标，并且是相互依赖的。如果数据库系统只执行这些操作中的一部分，则可能会破坏事务的总体目标，而原子性消除了系统只处理部分操作的可能性。 9.1.2 一致性​ 一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。 ​ 例如：在转账时，只有保证转出和转入的金额一致才能构成事务。也就是说事务发生前和发生后，数据的总额依然匹配。 9.1.3 隔离性​ 隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。 ​ 例如：在转账时，只有当A账户中的转出和B账户中转入操作都执行成功后才能看到A账户中的金额减少以及B账户中的金额增多。并且其他的事务对于转账操作的事务是不能产生任何影响的。 9.1.4 持久性​ 持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。 9.2 事务的并发问题9.2.1 脏读（Dirty read）​ 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 9.2.2 不可重复读（Unrepeatableread）​ 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 9.2.3 幻读（Phantom read）​ 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 9.2.4 总结​ 不可重复读的重点是修改，幻读的重点在于新增或者删除 ​ 解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表 9.2.5 事务的隔离级别​ 事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以MySQL中提供了四种隔离级别来解决上述问题。 ​ 事务的隔离级别从低到高依次为READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ以及SERIALIZABLE，隔离级别越低，越能支持高并发的数据库操作。 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED（读未提交） true true true READ COMMITTED（读已提交） false true true REPEATABLE READ（可重复读） false false true SERIALIZABLE（串行化） false false false ​","tags":[{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Spring","slug":"Spring","permalink":"https://lyblog2022.github.io/tags/Spring/"}]},{"title":"Servlet","date":"2022-06-04T08:59:30.000Z","path":"2022/06/04/study/Servlet/","text":"Servlet学习 1、Servlet的继承结构 2、Servlet接口 init()：创建servlet对象后立即调用该方法完成其他初始化工作 service()：处理客户端请求，执行业务操作，利用响应对象响应客户端请求 destory()：再销毁servlet对象之前调用该方法，释放资源 getServletConfig()：ServletConfig 是容器向Servlet传递参数的载体 getServletInfo()：获取servlet相关信息 3、ServletConfig 接口​ Servlet运行期间，需要一些辅助信息，这些信息可以在web.xml文件中，使用一个或多个元素进行配置。当tomacat初始化一个servlet时，会将该servlet的配置信息，封装到ServletConfig对象中，通过调用init(ServletConfig servletConfig)方法，将ServletConfig对象传递给Servlet 4、GenericServlet 抽象类​ GenericServlet是实现了Servlet接口的抽象类。在GenericServlet中进一步的定义了Servlet接口的具体实现，其设计的目的是为了和应用层协议解耦，再GenericServlet中包含了一个Service抽象方法，可以通过继承GenericServlet并实现Service方法实现请求的处理，但是需要将ServletRequest和ServletResponse 转化为HttpServletRequest和HttpServletResponse 5、HttpServlet​ 继承自GenericServlet，针对于处理Http协议的请求定制，在HttpServlet的service()方法中已经把ServletRequest和ServletResponse 转化为HttpServletRequest和HttpServletResponse 6、Servlet的生命周期​ servlet的生命周期是由容器管理的，分别经历4个阶段 阶段 字数 时机 创建 1次 第一次请求之后 初始化 1次 实例化之后 执行服务 多次 每次请求 销毁 1次 停止服务、 7、注意事项 在Servlet中一般不要轻易使用成员变量，可能会造成线程安全问题 如果要使用，应尽量避免对成员变量产生修改 如果要产生修改，应注意线程安全问题 8、ServletContext对象和ServletConfig对象​ ServletContext叫做Servlet上下文，服务器会为每一个web应用创建一个ServletContext对象，这个对象全局唯一，而且web应用中的所有Servlet都共享这个对象 8.1、ServletContext对象的作用 相对路径转为绝对路径 获取容器的附加信息 读取配置 全局容器 8.2、ServletContext的生命周期​ 当容器启动时会创建ServletContext对象并一直缓存该对象，直到容器关闭后该对象生命周期结束，ServletContext的生命周期非常长，所以在使用全局容器时不建议存放业务数据 8.3、ServletConfig对象​ ServletConfig对象对应web.xml文件中的节点，当Tomcat初始化一个Servlet时，会将该Servlet的配置信息，封装到一个ServletConfig对象中，可以通过该对象读取节点中的配置信息 9、请求转发9.1 forward转发9.1.1 forward转发处理流程 清空response存放的正在响应正文数据缓冲区 如果目标资源为Servlet或jsp，就调用他们的service方法，把该方法产生的响应结果发送到客户端；如果目标资源是静态文件中的HTML，就读取文件中的数据把它发送到客户端 9.1.2 forward处理特点 由于forward()方法先清空用于存放相应正文的缓冲区，因此源Servlet生成的响应结果不会被发送到客户端，只有目标资源生成的响应结果才会被发送到客户端 如果源Servlet在进行请求转发之前，已经提交了响应结(flushBuffer()，close()方法)，那么forward()方法会抛出异常，为避免异常，不应该在源servlet中提交响应结果 9.2 include转发9.2.1 include处理流程 如果目标资源为Servlet或者jsp，就调用他们的service方法，把该方法产生的响应正文添加到源Servlet的响应结果中；如果目标组建为HTML文档，就直接把文档的内容添加到源Servlet的响应结果中 返回到源Servlet的服务方法中，继续执行后续代码 9.2.2 include处理特点 源Servlet与被包含的目标资源的输出数据都会被添加到响应结果中 在目标资源对响应状态码或者响应开头所做的修改都会被忽略 10、Cookie对象和HttpSession对象​ Cookie对象和HttpSession对象的作用是维护客户端浏览器与服务端的会话状态的两个对象，二者的不同是Cookie是通过客户端浏览器实现会话的维持，而HttpSession是通过服务端来实现会话的维持 10.1 区别 cookie数据存放在客户的浏览器或系统文件中，httpsession中的数据存放在服务器中 cookie不安全，httpSession是安全的 单个cookie保存的数据不能超过4K，httpSession无限制","tags":[{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"servlet","slug":"servlet","permalink":"https://lyblog2022.github.io/tags/servlet/"}]},{"title":"MyBatis","date":"2022-06-04T08:59:00.000Z","path":"2022/06/04/study/MyBatis/","text":"MyBatis学习 1、简介Mybatis 是一款优秀的持久层框架，支持定制化SQL、存储过程及高级映射，可以使用简单的XML或注解来配置和映射原生信息 是一款半自动的持久层的半自动ORM映射框架 1.1 框架 框架是一个基本概念上的结构，用于解决或处理复杂的问题。 使用框架的优点：减少开发时间，降低开发难度，保证设计质量，降低程序员之间的沟通以及日后维护的成本 框架是一个半成品，已经对基础的代码进行了封装并提供响应的API，开发者再使用框架是直接调用封装好的API，可以省去很多代码编写，从而提升效率和开发速度 1.2 ORM Object-Relation Mapping，对象关系映射 它的作用是在关系型数据库和对象之间做一个映射，这样在操作具体数据的时候就像操作对象一样 1.2.1 持久化 持久：把数据保存到可永久保存的存储设备中 主要应用：将内存中的数据存储在关系型数据库中 1.2.2 持久层 专注于实现数据持久化应用领域的某一个特定系统的一个逻辑层面，将数据使用者和数据实体想关联（mapper层、DAO层） 2、Mybatis配置2.1 事务​ 在MyBatis 核心配置文件中envirment 中通过transactionManager配置事务的处理策略 JDBC：该配置使用了JDBC的提交及回滚，依赖于从数据源得到的链接来管理事务范围 MANAGED：该配置几乎无任何操作，不提交或回滚一个链接，它会让容器来管理整个生命周期（Spring应用服务器的上下文），默认情况下会关闭链接，但一些容器不希望如此，因此如果需要从链接中停止它，将closeConnection的属性值设置为false，Mybatis本身并不会处理事务，而是交给其他框架去处理 2.2 映射文件的加载方式 mapper的映射文件的文件路径导入，使用的是mapper标签的resource属性 网络资源路径使用的是mapper的url属性 接口的全限定名导入使用的是mapper标签的class属性—–基于接口的代理模式 包扫描形式加载所有的mapper映射文件，使用的package标签 3、Mybatis 开发3.1 传递参数 ${} 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置 #{} 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理，更常用 4、MyBatis代理模式开发在MyBatis中提供了一种称为Mapper代理（接口绑定）的操作方式，在实际开发中也使用该方式 4.1 原理浅析​ 底层使用了动态代理模式，动态创建一个Mapper的一个代理对象并赋给接口使用 5、动态SQL​ MyBatis在简化操作方法上提出了动态SQL功能，将使用Java代码拼接SQL语句，改变为在XML映射文件中截止标签拼接SQL语句。相比而言，大大减少代码量，更灵活、有利于后期维护 ​ MyBatis中动态SQL是编写在mapper.xml中的，其语法和JSTL类似，但是却是基于强大的OGNL表达式实现的 ​ MyBatis也可以在注解中配置SQL，但是由于注解功能受限，尤其是对于复杂的SQL语句，可读性很差，所以较少使用 5.1 If标签条件查询，符合if的条件，则补充SQL语句 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mapper.StudentMapper&quot;&gt; &lt;select id=&quot;findByCondition&quot; resultType=&quot;Student&quot;&gt; select * from student where 1=1 &lt;if test=&quot;stuno != null&quot;&gt; and stuno =#&#123;stuno&#125; &lt;/if&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; and classname like concat(&#x27;%&#x27;,#&#123;classname&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; 5.2 Where标签用于处理where关键字和and 1234567891011&lt;select id=&quot;findStuByCondition&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;where&gt; &lt;if test=&quot;stuno != null&quot;&gt; and stuno= #&#123;stuno&#125; &lt;/if&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; and classname= #&#123;classname&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 5.3 Choose标签前面的when条件成立 后面的 when就不再判断了 12345678910111213&lt;select id=&quot;findStuByCondition&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;stuno != null&quot;&gt; and stuno= #&#123;stuno&#125; &lt;/when&gt; &lt;when test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; and classname= #&#123;classname&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 5.4 Set标签12345678910111213&lt;update id=&quot;updateStuByCondtion&quot; &gt; update student &lt;set&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27; &quot;&gt; , classname =#&#123;classname&#125; &lt;/if&gt; &lt;if test=&quot;stuno != null &quot;&gt; , stuname =#&#123;stuname&#125; &lt;/if&gt; &lt;/set&gt; where stuno =#&#123;stuno&#125;&lt;/update&gt; 5.5 Trim标签123456789101112131415161718&lt;update id=&quot;updateStuByCondition&quot; &gt; update student &lt;!--prefix 要增加什么前缀 prefixOverrides 要去除什么前缀 suffix 要增加什么后缀 suffixOverrides 要去除什么后缀 set 是trim的一种特殊情况 --&gt; &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot; &gt; &lt;if test=&quot;stuname != null and stuname != &#x27;&#x27;&quot;&gt; stuname= #&#123;stuname&#125;, &lt;/if&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; classname= #&#123;classname&#125;, &lt;/if&gt; &lt;/trim&gt; where stuno = #&#123;stuno&#125;&lt;/update&gt; 5.6 Bind标签一般用于处理模糊查询的模板 1234&lt;select id=&quot;findStuByClassName&quot; resultType=&quot;Student&quot;&gt; &lt;bind name=&quot;likePattern&quot; value=&quot;&#x27;%&#x27;+param1+&#x27;%&#x27;&quot;&gt;&lt;/bind&gt; select * from student where classname like #&#123;classname&#125;&lt;/select&gt; 6、缓存6.1 一级缓存​ 一级存储是SqlSession上的缓存，默认开启，是一种内存型缓存,不要求实体类对象实现Serializable接口 ​ 缓存中的数据使用键值对形式存储数据 ​ namespace+sqlid+args+offset&gt;&gt;&gt; hash值作为键,查询出的结果作为值 6.2 二级缓存​ 二级缓存是以namespace为标记的缓存，可以是由一个SqlSessionFactory创建的SqlSession之间共享缓存数据。默认并不开启，要求实体类必须实现序列化接口 注意： ​ 1、 MyBatis的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对JavaBean对象实现序列化接口。 ​ 2、二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响 ​ 3、加入Cache元素后，会对相应命名空间所有的select元素查询结果进行缓存，而其中的insert、update、delete在操作是会清空整个namespace的缓存 ​ 4、cache 有一些可选的属性 type, eviction, flushInterval, size, readOnly, blocking。 1&lt;cache type=&quot;&quot; readOnly=&quot;&quot; eviction=&quot;&quot;flushInterval=&quot;&quot;size=&quot;&quot;blocking=&quot;&quot;/&gt; 属性 含义 默认值 type 自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口 null readOnly 是否只读 true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。false:会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全 false eviction 缓存策略LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。FIFO – 先进先出：按对象进入缓存的顺序来移除它们。SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 LRU flushInterval 刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，只有执行update、insert、delete语句才会刷新 null size 缓存对象个数 1024 blocking 是否使用阻塞性缓存BlockingCachetrue：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，否则会在查询数据库以后再释放锁，保证只有一个线程到数据库中查找指定key对应的数据false：不使用阻塞性缓存，性能更好 false ​ 5、如果在加入Cache元素的前提下让个别select 元素不使用缓存，可以使用useCache属性，设置为false。**useCache**控制当前sql语句是否启用缓存 flushCache控制当前sql执行一次后是否刷新缓存 1&lt;select id=&quot;findStuByCondition&quot; resultType=&quot;Student&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt; 6.3 三方缓存 分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.ehcache,redis ,memcache缓存框架。 Ehcache：是一种广泛使用的开源java分布式缓存。主要面向通用缓存，javaEE 和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式web application的","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://lyblog2022.github.io/tags/MyBatis/"},{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"518总结--post请求调用接口","date":"2022-05-18T13:06:35.000Z","path":"2022/05/18/dailysummary/20220518/dailysummary/","text":"使用post方式调用接口并传递参数 方式一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.summary;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import com.alibaba.fastjson.JSONObject;public class Summary &#123; /** * 发送post请求 * @param url：请求URL * @param headerParamsJson：请求header参数 * @param paramJson：请求参数 * @return */ public JSONObject sendData(String url, JSONObject headerParamsJson, JSONObject paramJson) &#123; JSONObject resultJson = new JSONObject(); // 发送post请求 try &#123; HttpPost httppost = new HttpPost(url); RequestConfig defaultRequestConfig = RequestConfig.custom().setConnectTimeout(5000) .setConnectionRequestTimeout(5000).setSocketTimeout(15000).build(); httppost.setConfig(defaultRequestConfig); StringEntity entity = new StringEntity(paramJson.toJSONString(), &quot;utf-8&quot;);// 解决中文乱码问题 entity.setContentEncoding(&quot;UTF-8&quot;); entity.setContentType(&quot;text/json&quot;); httppost.setEntity(entity); httppost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); // 添加header参数 Iterator headerParamsIterator = headerParamsJson.entrySet().iterator(); while (headerParamsIterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) headerParamsIterator.next(); httppost.setHeader(entry.getKey().toString(), entry.getValue().toString()); &#125; // 装填参数 List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); if (paramJson != null) &#123; Iterator iterator = paramJson.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); nvps.add(new BasicNameValuePair((String) entry.getKey(), (String) entry.getValue())); &#125; &#125; UrlEncodedFormEntity reqEntity = new UrlEncodedFormEntity(nvps, &quot;utf-8&quot;); httppost.setEntity(reqEntity); // 执行post请求. CloseableHttpClient httpclient = HttpClients.createDefault(); CloseableHttpResponse response1 = httpclient.execute(httppost); String resultText = &quot;&quot;; try &#123; int statusCode = response1.getStatusLine().getStatusCode(); if (statusCode != 200) &#123; throw new RuntimeException(&quot;请求失败&quot;); &#125; else &#123; // 响应实体 HttpEntity entity2 = response1.getEntity(); if (entity2 != null) &#123; // 响应内容 resultText = EntityUtils.toString(entity2, Charset.forName(&quot;UTF-8&quot;)); resultJson = JSONObject.parseObject(resultText); &#125; &#125; resultJson.put(&quot;code&quot;, statusCode); &#125; finally &#123; response1.close(); &#125; &#125; catch (Exception e) &#123; resultJson.put(&quot;code&quot;, &quot;410&quot;); resultJson.put(&quot;err&quot;, e.toString()); &#125; return resultJson; &#125;&#125;","tags":[{"name":"接口调用","slug":"接口调用","permalink":"https://lyblog2022.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"}]}]