[{"title":"centos配置mysql环境","date":"2023-02-05T11:35:56.000Z","path":"2023/02/05/study/database/centos安装mysql/","text":"CentOS8安装MySQL环境，使用数据库软件远程链接，并配置主从连接 1、删除环境自带MySQL使用yml命令删除已经安装的MySQL 1yum remove -y mysql 使用find命令找到残留文件 1find / -name mysql 2、安装mysql执行以下命令： 12wget https://dev.mysql.com/get/mysql80-community-release-el8-1.noarch.rpmyum install mysql80-community-release-el8-1.noarch.rpm 查看mysql数据源是否安装成功 1yum repolist enabled | grep &quot;mysql.*-community.*&quot; 执行以下命令安装mysql 1yum install mysql-community-server --nogpgcheck 如果出现No match for argument: mysql-community-server可执行 yum module disable mysql命令 1yum module disable mysql // 禁用命令 3、启动启动mysql 1service mysqld start 报错： 正确启动命令： 12/bin/systemctl start mysqld.serviceservice mysqld status 4、登录并修改密码4.1 显示随机密码执行以下命令： 1grep &#x27;temporary password&#x27; /var/log/mysqld.log 最后的字符串即为生成的随机密码 4.2 登录执行以下命令： 1mysql -u root -p 4.3 修改密码【注意】密码先修改成”Root_2022”，因为我们随便修改密码时,一般都不满足它的策略，会报错误：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 【解决方案】一定要先修改默认密码为: Root_2022 满足它的策略,再进行下面的操作: 1234567891011121314151617181920212223242526mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Root_2023&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;+--------------------------------------+--------+| Variable_name | Value |+--------------------------------------+--------+| validate_password.check_user_name | ON || validate_password.dictionary_file | || validate_password.length | 8 || validate_password.mixed_case_count | 1 || validate_password.number_count | 1 || validate_password.policy | MEDIUM || validate_password.special_char_count | 1 |+--------------------------------------+--------+7 rows in set (0.01 sec)mysql&gt; set global validate_password.length=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password.policy=0; Query OK, 0 rows affected (0.00 sec)mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;db-password&#x27;;Query OK, 0 rows affected (0.00 sec) 5、开放远程访问创建权限记录 12mysql&gt; create user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;password&#x27;;Query OK, 0 rows affected (0.01 sec) 授权 12mysql&gt; grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;Query OK, 0 rows affected (0.00 sec) 关闭系统防火墙 1systemctl status firewalld.service //查看防火墙状态 ​ systemctl stop firewalld.service （关闭防火墙） systemctl start firewalld.service （开启防火墙） systemctl disable firewalld.service （禁止防火墙自启动） systemctl enable firewalld.service （防火墙随系统开启启动） 使用datagrip链接 ​ 6、配置主从现有两台服务器 192.168.213.170 和 192.168.213.171，在这两台服务器之间搭建一主一从MySQL，配置170为主，165为从 6.1 主数据库修改修改&#x2F;etc&#x2F;my.cnf ​ server-id值要唯一不能与从数据库重复； log-bin 设置为 mysql-bin； 关闭170的MySQL服务 1234[root@192 ~]# netstat -lnpt | grep mysqltcp6 0 0 :::33060 :::* LISTEN 38340/mysqld tcp6 0 0 :::3306 :::* LISTEN 38340/mysqld [root@192 ~]# kill -9 38340 再次启动mysql 6.2 从数据库修改修改&#x2F;etc&#x2F;my.cnf ​ server-id值要唯一不能与主数据库重复； log-bin 设置为 mysql-bin； 关闭171的MySQL服务 1234^[[A[root@192 ~]# netstat -lnpt | grep mysqltcp6 0 0 :::33060 :::* LISTEN 38329/mysqld tcp6 0 0 :::3306 :::* LISTEN 38329/mysqld [root@192 ~]# kill -9 38329 再次启动mysql 6.3 查看主服务器的状态12345678mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 | 157 | | | |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec) 6.4 从服务器执行12mysql&gt; change master to master_host=&#x27;192.168.213.170&#x27;, master_port=3306, master_user=&#x27;root&#x27;, master_password=&#x27;password&#x27;, master_log_file=&#x27;mysql-bin.000001&#x27;, master_log_pos=157;Query OK, 0 rows affected, 9 warnings (0.03 sec) master_host 为主服务器的地址 master_port 为MySQL端口号。 master_user 为主服务器的用户名。 master_password 为用户密码。 master_log_file 为主数据库中File处的值。 master_log_pos 为主数据库中Position处的值。 6.5 主从开启从：开启主从监控 12mysql&gt; start slave;Query OK, 0 rows affected (0.01 sec) 6.6 重置12mysql&gt; reset slave all;Query OK, 0 rows affected (0.02 sec) 6.7 显示主从状态12mysql&gt; show slave status;Empty set","tags":[{"name":"软件安装","slug":"软件安装","permalink":"https://lyblog2022.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"mysql","slug":"mysql","permalink":"https://lyblog2022.github.io/tags/mysql/"}]},{"title":"java并发编程--锁","date":"2023-01-29T10:03:09.000Z","path":"2023/01/29/study/java/并发编程/并发编程的锁/","text":"并发编程中的锁 1、锁的分类1.1 可重入锁、不可重入锁Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是可重入锁。 重入：当前线程获取到A锁，在获取之后尝试再次获取A锁是可以直接拿到的。 不可重入：当前线程获取到A锁，在获取之后尝试再次获取A锁，无法获取到的，因为A锁被当前线程占用着，需要等待自己释放锁再获取锁。 1.2 乐观锁、悲观锁Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是悲观锁。 Java中提供的CAS操作，就是乐观锁的一种实现。 悲观锁：获取不到锁资源时，会将当前线程挂起（进入BLOCKED、WAITING），线程挂起会涉及到用户态和内核态的切换，而这种切换是比较消耗资源的。 用户态：JVM可以自行执行的指令，不需要借助操作系统执行。 内核态：JVM不可以自行执行，需要操作系统才可以执行。 乐观锁：获取不到锁资源，可以再次让CPU调度，重新尝试获取锁资源。 Atomic原子性类中，就是基于CAS乐观锁实现的。 1.3 公平锁、非公平锁Java中提供的synchronized只能是非公平锁。 Java中提供的ReentrantLock，ReentrantReadWriteLock可以实现公平锁和非公平锁 公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队。直接排到B的后面，等待B拿到锁资源或者是B取消后，才可以尝试去竞争锁资源。 非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一波 拿到锁资源：开心，插队成功。 没有拿到锁资源：依然要排到B的后面，等待B拿到锁资源或者是B取消后，才可以尝试去竞争锁资源。 1.4 互斥锁、共享锁Java中提供的synchronized、ReentrantLock是互斥锁。 Java中提供的ReentrantReadWriteLock，有互斥锁也有共享锁。 互斥锁：同一时间点，只会有一个线程持有者当前互斥锁。 共享锁：同一时间点，当前共享锁可以被多个线程同时持有。 2、深入synchronized2.1 类锁、对象锁synchronized的使用一般就是同步方法和同步代码块。 synchronized的锁是基于对象实现的。 如果使用同步方法 static：此时使用的是当前类.class作为锁（类锁） 非static：此时使用的是当前对象做为锁（对象锁） 123456789101112131415161718192021public class MyThread &#123; public static void main(String[] args) &#123; // 锁的是，当前Test.class Test.a(); Test test = new Test(); // 锁的是new出来的test对象 test.b(); &#125;&#125;class Test &#123; public static synchronized void a() &#123; System.out.println(&quot;1111&quot;); &#125; public synchronized void b() &#123; System.out.println(&quot;2222&quot;); &#125;&#125; 2.2 synchronized的优化锁消除：在synchronized修饰的代码中，如果不存在操作临界资源的情况，会触发锁消除，你即便写了synchronized，他也不会触发。 1234public synchronized void method()&#123; // 没有操作临界资源 // 此时这个方法的synchronized你可以认为木有~~&#125; 锁膨胀：如果在一个循环中，频繁的获取和释放做资源，这样带来的消耗很大，锁膨胀就是将锁的范围扩大，避免频繁的竞争和获取锁资源带来不必要的消耗。 12345678910111213public void method()&#123; for(int i = 0;i &lt; 999999;i++)&#123; synchronized(对象)&#123; &#125; &#125; // 这是上面的代码会触发锁膨胀 synchronized(对象)&#123; for(int i = 0;i &lt; 999999;i++)&#123; &#125; &#125;&#125; 锁升级：ReentrantLock的实现，是先基于乐观锁的CAS尝试获取锁资源，如果拿不到锁资源，才会挂起线程。synchronized在JDK1.6之前，完全就是获取不到锁，立即挂起当前线程，所以synchronized性能比较差。 synchronized就在JDK1.6做了锁升级的优化 无锁、匿名偏向：当前对象没有作为锁存在。 偏向锁：如果当前锁资源，只有一个线程在频繁的获取和释放，那么这个线程过来，只需要判断，当前指向的线程是否是当前线程 。 如果是，直接拿着锁资源走。 如果当前线程不是我，基于CAS的方式，尝试将偏向锁指向当前线程。如果获取不到，触发锁升级，升级为轻量级锁。（偏向锁状态出现了锁竞争的情况） 轻量级锁：会采用自旋锁的方式去频繁的以CAS的形式获取锁资源（采用的是自适应自旋锁） 如果成功获取到，拿着锁资源走 如果自旋了一定次数，没拿到锁资源，锁升级。 重量级锁：就是最传统的synchronized方式，拿不到锁资源，就挂起当前线程。（用户态&amp;内核态） 2.3 synchronized的实现原理synchronized是基于对象实现的。 先要对Java中对象在堆内存的存储有一个了解。 展开MarkWord MarkWord中标记着四种锁的信息：无锁、偏向锁、轻量级锁、 2.4 synchronized的锁升级为了可以在Java中看到对象头的MarkWord信息，需要导入依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 锁默认情况下，开启了偏向锁延迟。 偏向锁在升级为轻量级锁时，会涉及到偏向锁撤销，需要等到一个安全点（STW），才可以做偏向锁撤销，在明知道有并发情况，就可以选择不开启偏向锁，或者是设置偏向锁延迟开启 因为JVM在启动时，需要加载大量的.class文件到内存中，这个操作会涉及到synchronized的使用，为了避免出现偏向锁撤销操作，JVM启动初期，有一个延迟4s开启偏向锁的操作 如果正常开启偏向锁了，那么不会出现无锁状态，对象会直接变为匿名偏向 123456789101112131415161718public static void main(String[] args) throws InterruptedException &#123; Thread.sleep(5000); Object o = new Object(); System.out.println(ClassLayout.parseInstance(o).toPrintable()); new Thread(() -&gt; &#123; synchronized (o)&#123; //t1 偏向锁 System.out.println(&quot;t1:&quot;+ClassLayout.parseInstance(o).toPrintable()); &#125; &#125;).start(); synchronized (o)&#123; System.out.println(&quot;main:&quot;+ClassLayout.parseInstance(o).toPrintable()); &#125;&#125; 整个锁升级状态的转变： Lock Record以及ObjectMonitor存储的内容","tags":[{"name":"java","slug":"java","permalink":"https://lyblog2022.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://lyblog2022.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"java并发编程--并发编程的三大特性","date":"2023-01-28T13:41:08.000Z","path":"2023/01/28/study/java/并发编程/并发编程的三大特性/","text":"java并发编程—-并发编程的三大特性 1、原子性1.1 什么是并发编程的原子性 不同的硬件和不同的操作系统在内存上的操作有一定差异的 Java为了解决相同代码在不同操作系统上出现的各种问题，用JMM（Java Memory Model）屏蔽掉各种硬件和操作系统带来的差异。 让Java的并发编程可以做到跨平台。 JMM规定所有变量都会存储在主内存中，在操作的时候，需要从主内存中复制一份到线程内存（CPU内存），在线程内部做计算。然后再写回主内存中（不一定！）。 原子性的定义：原子性指一个操作是不可分割的，不可中断的，一个线程在执行时，另一个线程不会影响到他。 并发编程的原子性用代码阐述： 12345678910111213141516171819202122232425262728private static int count;public static void increment()&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count++;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; increment(); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; increment(); &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count);&#125; 当前程序：多线程操作共享数据时，预期的结果，与最终的结果不符。 原子性：多线程操作临界资源，预期的结果与最终结果一致。 通过对这个程序的分析，可以查看出，++的操作，一共分为了三部，首先是线程从主内存拿到数据保存到CPU的寄存器中，然后在寄存器中进行+1操作，最终将结果写回到主内存当中。 1.2 保证并发编程的原子性1.2.1 synchronized因为++操作可以从指令中查看到 可以在方法上追加synchronized关键字或者采用同步代码块的形式来保证原子性 synchronized可以让避免多线程同时操作临街资源，同一时间点，只会有一个线程正在操作临界资源 1.2.2 CASCAS：compare and swap也就是比较和交换，他是一条CPU的并发原语。 他在替换内存的某个位置的值时，首先查看内存中的值与预期值是否一致，如果一致，执行替换操作。这个操作是一个原子性操作。 Java中基于Unsafe的类提供了对CAS的操作的方法，JVM会帮助我们将方法实现CAS汇编指令。 但是要清楚CAS只是比较和交换，在获取原值的这个操作上，需要你自己实现。 12345678910111213141516171819private static AtomicInteger count = new AtomicInteger(0);public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; count.incrementAndGet(); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; count.incrementAndGet(); &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count);&#125; CAS的缺点：CAS只能保证对一个变量的操作是原子性的，无法实现对多行代码实现原子性。 CAS的问题： ABA问题： 问题如下: 可以引入版本号的方式，来解决ABA的问题。Java中提供了一个类在CAS时，针对各个版本追加版本号的操作。 AtomicStampeReference AtomicStampedReference在CAS时，不但会判断原值，还会比较版本信息。 示例： 123456789101112public static void main(String[] args) &#123; AtomicStampedReference&lt;String&gt; reference = new AtomicStampedReference&lt;&gt;(&quot;AAA&quot;,1); String oldValue = reference.getReference(); int oldVersion = reference.getStamp(); boolean b = reference.compareAndSet(oldValue, &quot;B&quot;, oldVersion, oldVersion + 1); System.out.println(&quot;修改1版本的：&quot; + b +&quot; value:&quot;+reference.getReference()+&quot; version:&quot;+reference.getStamp()); boolean c = reference.compareAndSet(&quot;B&quot;, &quot;C&quot;, 1, 1 + 1); System.out.println(&quot;修改2版本的：&quot; + c+&quot; value:&quot;+reference.getReference()+&quot; version:&quot;+reference.getStamp());&#125; 自旋时间过长问题： 可以指定CAS一共循环多少次，如果超过这个次数，直接失败&#x2F;或者挂起线程。（自旋锁、自适应自旋锁） 可以在CAS一次失败后，将这个操作暂存起来，后面需要获取结果时，将暂存的操作全部执行，再返回最后的结果。 只能保证一个共享变量的原子操作： 1.2.3 Lock锁实现： 12345678910111213141516171819202122232425262728293031323334353637private static int count;private static ReentrantLock lock = new ReentrantLock();public static void increment(int num) &#123; lock.lock(); try &#123; count+=num; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; increment(i); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; increment(i); &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count);&#125; ReentrantLock可以直接对比synchronized，在功能上来说，都是锁。 但是ReentrantLock的功能性相比synchronized更丰富。 ReentrantLock底层是基于AQS实现的，有一个基于CAS维护的state变量来实现锁的操作。 1.2.4 ThreadLocalThreadLocal保证原子性的方式，是不让多线程去操作临界资源，让每个线程去操作属于自己的数据 123456789101112131415static ThreadLocal tl1 = new ThreadLocal();static ThreadLocal tl2 = new ThreadLocal();public static void main(String[] args) &#123; tl1.set(&quot;123&quot;); tl2.set(&quot;456&quot;); Thread t1 = new Thread(() -&gt; &#123; System.out.println(&quot;t1-t1:&quot; + tl1.get()); System.out.println(&quot;t10t2:&quot; + tl2.get()); &#125;); t1.start(); System.out.println(&quot;main-t1:&quot; + tl1.get()); System.out.println(&quot;main-t2:&quot; + tl2.get());&#125; ThreadLocal实现原理： 每个Thread中都存储着一个成员变量，ThreadLocalMap ThreadLocal本身不存储数据，像是一个工具类，基于ThreadLocal去操作ThreadLocalMap ThreadLocalMap本身就是基于Entry[]实现的，因为一个线程可以绑定多个ThreadLocal，这样一来，可能需要存储多个数据，所以采用Entry[]的形式实现。 每一个线程都自己独立的ThreadLocalMap，再基于ThreadLocal对象本身作为key，对value进行存取 ThreadLocalMap的key是一个弱引用，弱引用的特点是，即便有弱引用，在GC时，也必须被回收。这里是为了在ThreadLocal对象失去引用后，如果key的引用是强引用，会导致ThreadLocal对象无法被回收 ThreadLocal内存泄漏问题： 如果ThreadLocal引用丢失，key因为弱引用会被GC回收掉，如果同时线程还没有被回收，就会导致内存泄漏，内存中的value无法被回收，同时也无法被获取到。 只需要在使用完毕ThreadLocal对象之后，及时的调用remove方法，移除Entry即可 2、可见性2.1 什么是可见性可见性问题是基于CPU位置出现的，CPU处理速度非常快，相对CPU来说，去主内存获取数据这个事情太慢了，CPU就提供了L1，L2，L3的三级缓存，每次去主内存拿完数据后，就会存储到CPU的三级缓存，每次去三级缓存拿数据，效率肯定会提升。 这就带来了问题，现在CPU都是多核，每个线程的工作内存（CPU三级缓存）都是独立的，会告知每个线程中做修改时，只改自己的工作内存，没有及时的同步到主内存，导致数据不一致问题。 可见性问题的代码逻辑 123456789101112131415private static boolean flag = true;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while (flag) &#123; // .... &#125; System.out.println(&quot;t1线程结束&quot;); &#125;); t1.start(); Thread.sleep(10); flag = false; System.out.println(&quot;主线程将flag改为false&quot;);&#125; 2.2 解决可见性的方式2.2.1 volatilevolatile是一个关键字，用来修饰成员变量。 如果属性被volatile修饰，相当于会告诉CPU，对当前属性的操作，不允许使用CPU的缓存，必须去和主内存操作 volatile的内存语义： volatile属性被写：当写一个volatile变量，JMM会将当前线程对应的CPU缓存及时的刷新到主内存中 volatile属性被读：当读一个volatile变量，JMM会将对应的CPU缓存中的内存设置为无效，必须去主内存中重新读取共享变量 其实加了volatile就是告知CPU，对当前属性的读写操作，不允许使用CPU缓存，加了volatile修饰的属性，会在转为汇编之后后，追加一个lock的前缀，CPU执行这个指令时，如果带有lock前缀会做两个事情： 将当前处理器缓存行的数据写回到主内存 这个写回的数据，在其他的CPU内核的缓存中，直接无效。 总结：volatile就是让CPU每次操作这个数据时，必须立即同步到主内存，以及从主内存读取数据。 123456789101112131415private volatile static boolean flag = true;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while (flag) &#123; // .... &#125; System.out.println(&quot;t1线程结束&quot;); &#125;); t1.start(); Thread.sleep(10); flag = false; System.out.println(&quot;主线程将flag改为false&quot;);&#125; 2.2.2 synchronized如果涉及到了synchronized的同步代码块或者是同步方法，获取锁资源之后，将内部涉及到的变量从CPU缓存中移除，必须去主内存中重新拿数据，而且在释放锁之后，会立即将CPU缓存中的数据同步到主内存。 12345678910111213141516171819private static boolean flag = true;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while (flag) &#123; synchronized (MyThread.class)&#123; //... &#125; System.out.println(111); &#125; System.out.println(&quot;t1线程结束&quot;); &#125;); t1.start(); Thread.sleep(10); flag = false; System.out.println(&quot;主线程将flag改为false&quot;);&#125; 2.2.3 LockLock锁保证可见性的方式和synchronized完全不同，synchronized基于他的内存语义，在获取锁和释放锁时，对CPU缓存做一个同步到主内存的操作。 Lock锁是基于volatile实现的。Lock锁内部再进行加锁和释放锁时，会对一个由volatile修饰的state属性进行加减操作。 如果对volatile修饰的属性进行写操作，CPU会执行带有lock前缀的指令，CPU会将修改的数据，从CPU缓存立即同步到主内存，同时也会将其他的属性也立即同步到主内存中。还会将其他CPU缓存行中的这个数据设置为无效，必须重新从主内存中拉取。 12345678910111213141516171819202122private static boolean flag = true;private static Lock lock = new ReentrantLock();public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while (flag) &#123; lock.lock(); try&#123; //... &#125;finally &#123; lock.unlock(); &#125; &#125; System.out.println(&quot;t1线程结束&quot;); &#125;); t1.start(); Thread.sleep(10); flag = false; System.out.println(&quot;主线程将flag改为false&quot;);&#125; 2.2.4 finalfinal修饰的属性，在运行期间是不允许修改的，这样一来，就间接的保证了可见性，所有多线程读取final属性，值肯定是一样。 final并不是说每次取数据从主内存读取，他没有这个必要，而且final和volatile是不允许同时修饰一个属性的 final修饰的内容已经不允许再次被写了，而volatile是保证每次读写数据去主内存读取，并且volatile会影响一定的性能，就不需要同时修饰。 3、有序性3.1 什么是有序性在Java中，.java文件中的内容会被编译，在执行前需要再次转为CPU可以识别的指令，CPU在执行这些指令时，为了提升执行效率，在不影响最终结果的前提下（满足一些要求），会对指令进行重排。 指令乱序执行的原因，是为了尽可能的发挥CPU的性能。 Java中的程序是乱序执行的。 Java程序验证乱序执行效果： 12345678910111213141516171819202122232425262728static int a,b,x,y;public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; a = 0; b = 0; x = 0; y = 0; Thread t1 = new Thread(() -&gt; &#123; a = 1; x = b; &#125;); Thread t2 = new Thread(() -&gt; &#123; b = 1; y = a; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); if(x == 0 &amp;&amp; y == 0)&#123; System.out.println(&quot;第&quot; + i + &quot;次，x = &quot;+ x + &quot;,y = &quot; + y); &#125; &#125;&#125; 单例模式由于指令重排序可能会出现问题： 线程可能会拿到没有初始化的对象，导致在使用时，可能由于内部属性为默认值，导致出现一些不必要的问题 3.2 解决指令重排问题3.2.1 as-if-serialas-if-serial语义： 不论指定如何重排序，需要保证单线程的程序执行结果是不变的。 而且如果存在依赖的关系，那么也不可以做指令重排。 123456789// 这种情况肯定不能做指令重排序int i = 0;i++;// 这种情况肯定不能做指令重排序int j = 200;j * 100;j + 100;// 这里即便出现了指令重排，也不可以影响最终的结果，20100 3.2.2 happens-before具体规则： 单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。 volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作。 happen-before的传递性原则： 如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。 JMM只有在不出现上述8中情况时，才不会触发指令重排效果。 不需要过分的关注happens-before原则，只需要可以写出线程安全的代码就可以了。 3.2.3 volatile如果需要让程序对某一个属性的操作不出现指令重排，除了满足happens-before原则之外，还可以基于volatile修饰属性，从而对这个属性的操作，就不会出现指令重排的问题了。 volatile如何实现的禁止指令重排？ 内存屏障概念。将内存屏障看成一条指令。 会在两个操作之间，添加上一道指令，这个指令就可以避免上下执行的其他指令进行重排序。","tags":[{"name":"java","slug":"java","permalink":"https://lyblog2022.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://lyblog2022.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"java并发编程--线程","date":"2022-12-26T03:06:21.000Z","path":"2022/12/26/study/java/并发编程/线程/","text":"java并发编程—-线程的基础概念 1、基础概念1.1 进程与线程 进程：进程是指运行中的程序。 比如我们使用微信，浏览器，需要启动这个程序，操作系统会给这个程序分配一定的资源（占用内存资源）。 线程：线程是CPU调度的基本单位，每个线程执行的都是某一个进程的代码的某个片段。 举个栗子：房子与人 比如现在有一个100平的房子，这个方式可以看做是一个进程 房子里有人，人就可以看做成一个线程。 人在房子中做一个事情，比如吃饭，学习，睡觉。这个就好像线程在执行某个功能的代码。 所谓进程就是线程的容器，需要线程利用进程中的一些资源，处理一个代码、指令。最终实现进程锁预期的结果。 进程和线程的区别： 根本不同：进程是操作系统分配的资源，而线程是CPU调度的基本单位。 资源方面：同一个进程下的线程共享进程中的一些资源。线程同时拥有自身的独立存储空间。进程之间的资源通常是独立的。 数量不同：进程一般指的就是一个进程。而线程是依附于某个进程的，而且一个进程中至少会有一个或多个线程。 开销不同：毕竟进程和线程不是一个级别的内容，线程的创建和终止的时间是比较短的。而且线程之间的切换比进程之间的切换速度要快很多。而且进程之间的通讯很麻烦，一般要借助内核才可以实现，而线程之间通讯，相当方面。 1.2 多线程多线程是指：单个进程中同时运行多个线程。 使用多线程的目的：为了提高CPU的利用率。可以通过避免一些网络IO或者磁盘IO等需要等待的操作，让CPU去调度其他线程。这样可以大幅度的提升程序的效率，提高用户的体验。 局限： 如果线程数量特别多，CPU在切换线程上下文时，会额外造成很大的消耗。 任务的拆分需要依赖业务场景，有一些异构化的任务，很难对任务拆分，还有很多业务并不是多线程处理更好。 线程安全问题：虽然多线程带来了一定的性能提升，但是再做一些操作时，多线程如果操作临界资源，可能会发生一些数据不一致的安全问题，甚至涉及到锁操作时，会造成死锁问题。 1.3 串行、并行、并发串行： ​ 串行就是一个一个排队，第一个做完，第二个才能上。 并行： ​ 并行就是同时处理。（一起上！！！） 并发： ​ 这里的并发并不是三高中的高并发问题，这里是多线程中的并发概念（CPU调度线程的概念）。CPU在极短的时间内，反复切换执行不同的线程，看似好像是并行，但是只是CPU高速的切换。 并行包括并发 并行就是多核CPU同时调度多个线程，是真正的多个线程同时执行。 单核CPU无法实现并行效果，单核CPU是并发。 1.4 同步异步、阻塞非阻塞同步与异步：执行某个功能后，被调用者是否会主动反馈信息 阻塞和非阻塞：执行某个功能后，调用者是否需要一直等待结果的反馈。 两个概念看似相似，但是侧重点是完全不一样的。 同步阻塞：比如用锅烧水，水开后，不会主动通知你。烧水开始执行后，需要一直等待水烧开。 同步非阻塞：比如用锅烧水，水开后，不会主动通知你。烧水开始执行后，不需要一直等待水烧开，可以去执行其他功能，但是需要时不时的查看水开了没。 异步阻塞：比如用水壶烧水，水开后，会主动通知你水烧开了。烧水开始执行后，需要一直等待水烧开。 异步非阻塞：比如用水壶烧水，水开后，会主动通知你水烧开了。烧水开始执行后，不需要一直等待水烧开，可以去执行其他功能。 异步非阻塞这个效果是最好的，平时开发时，提升效率最好的方式就是采用异步非阻塞的方式处理一些多线程的任务。 2、线程的创建线程的创建分为三种方式 2.1 集成Thread类，重写run方法启动线程是调用start方法，这样会创建一个新的线程，并执行线程的任务。 如果直接调用run方法，这样会让当前线程执行run方法中的业务逻辑。 1234567891011121314151617181920212223242526package com.thread;/** * @description: * @author: ly * @create: 2022-12-26 11:21 * @version: 1.0 **/public class MyThread &#123; public static void main(String[] args) &#123; Slave slave = new Slave(); slave.start(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;main:&quot;+i); &#125; &#125;&#125;class Slave extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;Slave:&quot;+i); &#125; &#125;&#125; 2.2 实现Runnable接口，重写run方法123456789101112131415161718192021222324252627package com.thread;/** * @description: * @author: ly * @create: 2022-12-26 11:21 * @version: 1.0 **/public class MyThread &#123; public static void main(String[] args) &#123; Slave slave = new Slave(); Thread thread = new Thread(slave); thread.start(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;main:&quot;+i); &#125; &#125;&#125;class Slave implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;Slave:&quot;+i); &#125; &#125;&#125; 常用的方式： 匿名内部类 12345678Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;匿名内部类&quot;+i); &#125; &#125; &#125;); lambda 12345Thread thread2 = new Thread(()-&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;lambda&quot;+i); &#125; &#125;); 2.3 实现Callable重写call方法，配合FutrueTaskCallable一般用于有返回结果的同步非阻塞的执行方法 12345678910111213141516171819202122232425262728293031323334package com.thread;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @description: * @author: ly * @create: 2022-12-26 11:21 * @version: 1.0 **/public class MyThread &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; Slave slave = new Slave(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(slave); Thread thread = new Thread(futureTask); thread.start(); Integer count = futureTask.get(); System.out.println(count); &#125;&#125;class Slave implements Callable &#123; @Override public Integer call() throws Exception &#123; int count=0; for (int i = 0; i &lt; 100; i++) &#123; count+=i; &#125; return count; &#125;&#125; 3、线程的基本使用3.1 线程状态java中的线程状态 NEW：Thread对象被创建出来了，但是还没有执行start方法。 RUNNABLE：Thread对象调用了start方法，就为RUNNABLE状态（CPU调度&#x2F;没有调度） BLOCKED、WAITING、TIME_WAITING：都可以理解为是阻塞、等待状态，因为处在这三种状态下，CPU不会调度当前线程 BLOCKED：synchronized没有拿到同步锁，被阻塞的情况 WAITING：调用wait方法就会处于WAITING状态，需要被手动唤醒 TIME_WAITING：调用sleep方法或者join方法，会被自动唤醒，无需手动唤醒 TERMINATED：run方法执行完毕，线程生命周期到头了 代码验证： NEW: 123456public static void main(String[] args) &#123; Thread thread = new Thread(()-&gt;&#123; &#125;); System.out.println(thread.getState());&#125; RUNNABLE: 12345678910public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; while(true)&#123; &#125; &#125;); thread.start(); Thread.sleep(500); System.out.println(thread.getState());&#125; BLOCKED： 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Object obj = new Object(); Thread thread = new Thread(()-&gt;&#123; synchronized (obj)&#123; &#125; &#125;); synchronized (obj)&#123; thread.start(); Thread.sleep(500); System.out.println(thread.getState()); &#125;&#125; WAITING: 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; Object obj = new Object(); Thread thread = new Thread(()-&gt;&#123; synchronized (obj)&#123; try &#123; obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); Thread.sleep(500); System.out.println(thread.getState());&#125; TIMED_WAITING： 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Object obj = new Object(); Thread thread = new Thread(()-&gt;&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); thread.start(); Thread.sleep(500); System.out.println(thread.getState());&#125; TERMINATED: 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Object obj = new Object(); Thread thread = new Thread(()-&gt;&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); thread.start(); Thread.sleep(500); System.out.println(thread.getState());&#125; 3.2 线程常用的方法3.2.1 获取当前线程Thread的静态方法获取当前线程对象 123456public static void main(String[] args) throws InterruptedException &#123; Thread thread = Thread.currentThread(); System.out.println(thread); // &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; + group.getName() + &quot;]&quot;; // Thread[main,5,main]&#125; 3.2.2 获取线程的名称在构建Thread对象完毕后，一定要设置一个有意义的名称，方面后期排查错误 1234567public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()); &#125;); thread.setName(&quot;demo1&quot;); thread.start();&#125; 3.2.3 设置线程优先级其实就是CPU调度线程的优先级 java中给线程设置的优先级别有10个级别，从1~10任取一个整数。 如果超出这个范围，会排除参数异常的错误 12345678910111213141516public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;t1:&quot; + i); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;t2:&quot; + i); &#125; &#125;); t1.setPriority(1); t2.setPriority(10); t2.start(); t1.start();&#125; 3.2.4 线程的让步可以通过Thread的静态方法yield，让当前线程从运行状态转变为就绪状态。 1234567891011121314151617public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i==50) &#123; Thread.yield(); &#125; System.out.println(&quot;t1:&quot; + i); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;t2:&quot; + i); &#125; &#125;); t2.start(); t1.start();&#125; 3.2.5 线程的休眠Thread的静态方法，让线程从运行状态转变为等待状态 sleep有两个方法重载： 第一个就是native修饰的，让线程转为等待状态的效果 第二个是可以传入毫秒和一个纳秒的方法（如果纳秒值大于等于0.5毫秒，就给休眠的毫秒值+1。如果传入的毫秒值是0，纳秒值不为0，就休眠1毫秒） sleep会抛出一个InterruptedException 12345public static void main(String[] args) throws InterruptedException &#123; System.out.println(System.currentTimeMillis()); Thread.sleep(1000); System.out.println(System.currentTimeMillis());&#125; 3.2.6 线程的强占Thread的非静态方法join方法 需要在某一个线程下去调用这个方法 如果在main线程中调用了t1.join()，那么main线程会进入到等待状态，需要等待t1线程全部执行完毕，在恢复到就绪状态等待CPU调度 如果在main线程中调用了t1.join(2000)，那么main线程会进入到等待状态，需要等待t1执行2s后，在恢复到就绪状态等待CPU调度。如果在等待期间，t1已经结束了，那么main线程自动变为就绪状态等待CPU调度。 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;t1:&quot; + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.start(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;main:&quot;+i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (i==1) &#123; try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.2.7 守护线程默认情况下，线程都是非守护线程 JVM会在程序中没有非守护线程时，结束掉当前JVM 主线程默认是非守护线程，如果主线程执行结束，需要查看当前JVM内是否还有非守护线程，如果没有JVM直接停止 123456789101112131415public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;t1:&quot; + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.setDaemon(true); t1.start();&#125; 3.2.8 线程的等待和唤醒可以让获取synchronized锁资源的线程通过wait方法进去到锁的等待池，并且会释放锁资源 可以让获取synchronized锁资源的线程，通过notify或者notifyAll方法，将等待池中的线程唤醒，添加到锁池中 notify随机的唤醒等待池中的一个线程到锁池 notifyAll将等待池中的全部线程都唤醒，并且添加到锁池 在调用wait方法和notify以及norifyAll方法时，必须在synchronized修饰的代码块或者方法内部才可以，因为要操作基于某个对象的锁的信息维护。 1234567891011121314151617181920212223242526272829public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; sync(); &#125;,&quot;t1&quot;); Thread t2 = new Thread(() -&gt; &#123; sync(); &#125;,&quot;t2&quot;); t1.start(); t2.start(); Thread.sleep(2000); synchronized (MyThread.class)&#123; MyThread.class.notifyAll(); &#125;&#125;public static synchronized void sync() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 5) &#123; MyThread.class.wait(); &#125; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 3.3 线程结束方式线程结束方式很多，最常用就是让线程的run方法结束，无论是return结束，还是抛出异常结束，都可以 3.3.1 stop方法（不用）强制让线程结束，不推荐使用当然当然方式，但是，他确实可以把线程干掉 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); t1.start(); Thread.sleep(500); t1.stop(); System.out.println(t1.getState());&#125; 3.3.2 使用共享变量（很少用）这种方式用的也不多，有的线程可能会通过死循环来保证一直运行。 咱们可以通过修改共享变量在破坏死循环，让线程退出循环，结束run方法 12345678910111213static volatile boolean flag = true;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while(flag)&#123; System.out.println(&quot;任务处理中&quot;); &#125; System.out.println(&quot;任务结束&quot;); &#125;); t1.start(); Thread.sleep(500); flag = false;&#125; 3.3.3 interrupt方式中断标记位 1234567891011121314151617181920212223public static void main(String[] args) throws InterruptedException &#123; // 线程默认情况下， interrupt标记位：false System.out.println(Thread.currentThread().isInterrupted()); // 执行interrupt之后，再次查看打断信息 Thread.currentThread().interrupt(); // interrupt标记位：ture System.out.println(Thread.currentThread().isInterrupted()); // 返回当前线程，并归位为false interrupt标记位：ture System.out.println(Thread.interrupted()); // 已经归位了 System.out.println(Thread.interrupted()); // ============================= Thread t1 = new Thread(() -&gt; &#123; while(!Thread.currentThread().isInterrupted())&#123; System.out.println(&quot;t1执行&quot;) &#125; System.out.println(&quot;t1结束&quot;); &#125;); t1.start(); Thread.sleep(500); t1.interrupt();&#125; 通过打断WAITING或者TIMED_WAITING状态的线程，从而抛出异常自行处理 这种停止线程方式是最常用的一种，在框架和JUC中也是最常见的 12345678910111213141516171819public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while(true)&#123; // 获取任务 // 拿到任务，执行任务 // 没有任务了，让线程休眠 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println(&quot;基于打断形式结束当前线程&quot;); return; &#125; &#125; &#125;); t1.start(); Thread.sleep(500); t1.interrupt();&#125;","tags":[{"name":"java","slug":"java","permalink":"https://lyblog2022.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://lyblog2022.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"通过URL下载文件","date":"2022-10-30T04:27:27.000Z","path":"2022/10/30/summary/20221030/通过URL下载文件/","text":"java通过URL下载文件到本地 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 从网络Url中下载文件 * * @param urlStr * @param fileName * @param savePath * @throws IOException */ public static void downLoadFromUrl(String urlStr, String fileName, String savePath) throws IOException &#123; URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //设置超时间为3秒 conn.setConnectTimeout(3 * 1000); //防止屏蔽程序抓取而返回403错误 conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;); //得到输入流 InputStream inputStream = conn.getInputStream(); //获取自己数组 byte[] getData = readInputStream(inputStream); //文件保存位置 File saveDir = new File(savePath); if (!saveDir.exists()) &#123; saveDir.mkdir(); &#125; File file = new File(saveDir + File.separator + fileName); FileOutputStream fos = new FileOutputStream(file); fos.write(getData); if (fos != null) &#123; fos.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; System.out.println(&quot;info:&quot; + url + &quot; download success&quot;); &#125; /** * 从输入流中获取字节数组 * * @param inputStream * @return * @throws IOException */ public static byte[] readInputStream(InputStream inputStream) throws IOException &#123; byte[] buffer = new byte[1024]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((len = inputStream.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.close(); return bos.toByteArray(); &#125; public static void main(String[] args) &#123; try &#123; downLoadFromUrl(&quot;https://dss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/topnav/newfanyi-da0cea8f7e.png&quot;, &quot;百度.png&quot;, &quot;E:\\\\&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;","tags":[]},{"title":"使用post方式调用接口并传递参数","date":"2022-05-18T13:06:35.000Z","path":"2022/05/18/summary/20220518/使用post方式调用接口并传递参数/","text":"使用post方式调用接口并传递参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.summary;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import com.alibaba.fastjson.JSONObject;public class Summary &#123; /** * 发送post请求 * @param url：请求URL * @param headerParamsJson：请求header参数 * @param paramJson：请求参数 * @return */ public JSONObject sendData(String url, JSONObject headerParamsJson, JSONObject paramJson) &#123; JSONObject resultJson = new JSONObject(); // 发送post请求 try &#123; HttpPost httppost = new HttpPost(url); RequestConfig defaultRequestConfig = RequestConfig.custom().setConnectTimeout(5000) .setConnectionRequestTimeout(5000).setSocketTimeout(15000).build(); httppost.setConfig(defaultRequestConfig); StringEntity entity = new StringEntity(paramJson.toJSONString(), &quot;utf-8&quot;);// 解决中文乱码问题 entity.setContentEncoding(&quot;UTF-8&quot;); entity.setContentType(&quot;text/json&quot;); httppost.setEntity(entity); httppost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); // 添加header参数 Iterator headerParamsIterator = headerParamsJson.entrySet().iterator(); while (headerParamsIterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) headerParamsIterator.next(); httppost.setHeader(entry.getKey().toString(), entry.getValue().toString()); &#125; // 装填参数 List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); if (paramJson != null) &#123; Iterator iterator = paramJson.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); nvps.add(new BasicNameValuePair((String) entry.getKey(), (String) entry.getValue())); &#125; &#125; UrlEncodedFormEntity reqEntity = new UrlEncodedFormEntity(nvps, &quot;utf-8&quot;); httppost.setEntity(reqEntity); // 执行post请求. CloseableHttpClient httpclient = HttpClients.createDefault(); CloseableHttpResponse response1 = httpclient.execute(httppost); String resultText = &quot;&quot;; try &#123; int statusCode = response1.getStatusLine().getStatusCode(); if (statusCode != 200) &#123; throw new RuntimeException(&quot;请求失败&quot;); &#125; else &#123; // 响应实体 HttpEntity entity2 = response1.getEntity(); if (entity2 != null) &#123; // 响应内容 resultText = EntityUtils.toString(entity2, Charset.forName(&quot;UTF-8&quot;)); resultJson = JSONObject.parseObject(resultText); &#125; &#125; resultJson.put(&quot;code&quot;, statusCode); &#125; finally &#123; response1.close(); &#125; &#125; catch (Exception e) &#123; resultJson.put(&quot;code&quot;, &quot;410&quot;); resultJson.put(&quot;err&quot;, e.toString()); &#125; return resultJson; &#125;&#125;","tags":[{"name":"httpClient","slug":"httpClient","permalink":"https://lyblog2022.github.io/tags/httpClient/"},{"name":"接口调用","slug":"接口调用","permalink":"https://lyblog2022.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"}]}]