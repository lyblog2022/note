[{"title":"Spring","date":"2022-06-04T08:59:55.000Z","path":"2022/06/04/study/Spring/","text":"Spring学习 1、Spring框架1.1 Spring框架​ Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ​ —-百度百科 目的：解决企业应用开发的复杂性 功能：使用基本的JavaBean代替EJB，并提供更对的企业应用功能 范围：任何Java应用 ​ Spring是分层的全栈式的轻量级开发框架，以IOC和AOP为核心 1.2 优点 方便解耦，简化开发 Spring通过容器，将对象的创建从代码中剥离出来，交给Spring控制，避免直接编码造成模块之间的耦合度高，用户也不必自己编码处理对象的单例和多例控制，主要关注接口功能即可，不用关注具体使用哪个实现类和实现细节问题 AOP切面编程 AOP切面编程是程序设计的一种概念，Spring对该概念实现的比较好，通过切面编程我们可以在不修改原有代码的情况下实现功能的增加，通常用于事务控制、日志记录、性能检测、权限控制等等 声明式事务 事务的控制可以托管给Spring，我们通过注解或者配置文件声明事务的处理方式即可，不用我们自己去编码处理 整合JUNIT，方便测试 spring整合JUNIT单元测试，对于项目的功能都可以进行轻松快速的测试，便于我们调试程序 方便整合各种优秀的框架 丰富的功能封装 spring对JAVAEE(JDBC ，JAVAMail)都进行了一系列的封装，简化我们对于API的使用，提高程序的开发效率 规范的源码学习样本 spring的源码设计巧妙，结构清晰，大量使用了设计模式，是java代码规范编写的典范 2、Spring模块 2.1 Data Access/Integration（数据访问／集成）数据访问&#x2F;集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块 JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。 ORM 模块：对流行的对象关系映射 API，包括 JPA、JDO、Hibernate和 iBatis 提供了的集成层。 OXM 模块：提供了一个支持对象XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。 JMS 模块：指JAVA消息服务，包含的功能为生产和消费的信息。 Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。 2.2 Web 模块Spring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件 Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。 Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web应用程序。 Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。 Portlet 模块：提供了在 Portlet 环境中使用 MVC实现，类似 Web-Servlet 模块的功能。 2.3 Core Container（核心容器）Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成 Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。 Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。 Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。 Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。 2.4 其他模块Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块 AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。 Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。 Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。 Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。 3、Spring_IOC3.1 控制反转​ 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫依赖查找（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。–【百度】 ​ 简单来说，创建对象的权利，或者是控制的位置，由Java代码转移到Spring容器，由Spring的容器控制对象的创建，就是控制反转，Spring创建对象时，会读取配置文件中的信息，然后使用反射创建好的对象之后在容器中存储起来，当需要某个对象时，通过id获取对象即可，不需要自己去new 3.2 原理分析3.2.1 XML解析1&lt;bean id=&quot;stuDao&quot; class=&quot;com.dao.impl.StuDaoImpl&quot;&gt;&lt;/bean&gt; ​ 将上面的信息读取进入程序 对象的ID ,一个是对象的类的全路径名 3.2.2 反射123456//获得类的字节码Class clazz =Class.forName(&quot;com.dao.impl.StuDaoImpl&quot;);//通过字节码实例化对象Object obj = clazz.newInstance(); //将对象放到一个map集合中map.put(&quot;empDao&quot;,obj) 3.2.3 工厂模式1234public Object getBean(String name)&#123; Object obj =map.get(name); return obj; &#125; IOC接口 BeanFactory 接口：IOC容器基本功能接口，是spring内部使用的接口，我们在处理业务时一般不直接使用该接口 ApplicationContext 接口：BeanFactory的子接口，提供更多更强大的功能，研发人员一般使用的接口 4、Spring_XML方式实现DIspring中的Bean的管理: Bean(汉译咖啡豆)，又称JAVABean，其实就是JAVA程序程序中的一个个对象，所以Bean的管理其实就是spring对于JAVA程序中的对象的管理 管理的内容 对象的创建（IOC）：控制反转，就是Spring给我们创建对象，然后我们直接用，不用自己NEW 属性的赋值（DI）：依赖注入，即创建属性时给对象属性赋值，对象功能的实现往往要依赖属性的值，由于对象属性不仅仅是基本数据类型，还可能是其他类或者引用类型，那么依赖注入将会把更多的对象之间的关系整理到一起，可以形成一个庞大的依赖关系，DI处理的是对象的属性赋值和互相依赖的关系 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--通过无参构造方法构造对象--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.bean.User&quot; name=&quot;user1&quot; scope=&quot;prototype&quot; lazy-init=&quot;true&quot;&gt;&lt;/bean&gt;&lt;!--id:对象的idclass:类的全路径名name:和id类似,一般不用scope：控制对象单例多例和使用范围 singleton：作用域(scope 默认值), Spring IOC容器中只会存在一个共享的bean实例 prototype：作用域部署的bean，每一次获取都会产生一个新的bean实例，相当与一个new的操作 request：表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 session：作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效 global session：作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义lazy-init：懒加载 调用getBean的时候再去实例化对象--&gt;&lt;!--通过set方法给对象属性赋值--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.bean.User&quot;&gt; &lt;property name=&quot;userid&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;abcdefg&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--通过有参构造给对象属性赋值--&gt;&lt;bean id=&quot;user2&quot; class=&quot;com.msb.bean.User&quot;&gt; &lt;constructor-arg name=&quot;userid&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;小明&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;password&quot; value=&quot;123456789&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--特殊符号--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.msb.bean.User&quot;&gt; &lt;!--null值--&gt; &lt;property name=&quot;userid&quot;&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;!--特殊符号 转译字符 &lt; &amp;lt; &gt;&amp;gt; &amp; &amp;amp; --&gt; &lt;property name=&quot;username&quot; value=&quot;&amp;amp;xiaoming&amp;lt;&amp;gt;&quot;&gt;&lt;/property&gt; &lt;!-- 特殊符号 &lt;![CDATA[内容]]&gt; --&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;&lt;![CDATA[&amp;&lt;123456&gt;]]&gt;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 5、Spring_Bean生命周期 通过构造器创建bean实例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行构造器 为bean属性赋值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行set方法 初始化bean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 调用bean的初始化方法,需要配置指定调用的方法 bean的获取&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 容器对象 getBean方法 容器关闭销毁bean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 调用销毁方法,需要配置指定调用的方法 6、Spring注解方式管理Bean6.1 注解方式创建对象IOC @Component：放在类上,用于标记，告诉spring当前类需要由容器实例化bean并放入容器中 @Controller：@Component子注解，用于实例化controller层bean @Service：@Component子注解，用于实例化service层bean @Repository：@Component子注解，用于实例化持久层bean 6.2 注解方式依赖注入DI @Autowired：根据属性数据类型自动装配 @Qualifier：根据属性名称注入依赖 @Resources：可以根据类型,也可以根据名称注入 @Value：注入普通数据类型(8+String) 7、Spring代理7.1 代理模式通过代理对象访问目标对象，可以在目标对象基础上增强额外的功能，如添加权限、访问控制等 7.2 静态代理​ 静态代理中代理类与被代理类都需要实现同一个接口，即一个静态代理类只能代理一个类，并且需要知道要代理哪个类才能编写代理类代码，如果有其他类想要使用代理类，就必须再写一个 ​ 在实际开发中是可能有非常多的类需要被代理，并且可能并不知道要代理哪个类，所以继续使用静态代理反而会增加更多的工作量，且效率低下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.test;/*** @Author: Ly* @Description: */public class Test1 &#123; public static void main(String[] args) &#123; Person person =new Person(&quot;张三&quot;); Court court=new Lawyer(person); court.doCourt(); &#125;&#125;// 接口interface Court&#123; void doCourt();&#125;// 代理类class Lawyer implements Court&#123; private Person person; public Lawyer(Person person) &#123; this.person = person; &#125; @Override public void doCourt() &#123; System.out.println(&quot;律师取证:视频证明张三当时正在旅游,不在案发现场&quot;); System.out.println(&quot;律师总结:张三不可能去杀人&quot;); person.doCourt(); &#125;&#125;// 被代理的类class Person implements Court&#123; private String name; public Person(String name) &#123; this.name = name; &#125; @Override public void doCourt() &#123; System.out.println(name+&quot;说:我没有杀人&quot;); &#125;&#125; 7.3 动态代理​ 动态代理可以针对于一些不特定的类或者一些不特定的方法进行代理，可以在程序运行时动态的改变代理的规则，代理类在程序运行时才创建的代理模式，在这种情况下，代理类并不是在Java代码中定义好，而是在程序运行时根据在Java代码中的指示动态生成的 Proxy动态代理：JDK动态代理，面向接口 cglib动态代理：第三方动态代理，面向父类 7.3.1 Proxy动态代理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.testProxy; import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/** * @Author: Ly * @Description: */public class Test1 &#123; public static void main(String[] args) &#123; Dinner dinner=new Person(&quot;张三&quot;); // 通过Porxy动态代理获得一个代理对象,在代理对象中,对某个方法进行增强 // ClassLoader loader,被代理的对象的类加载器 ClassLoader classLoader = dinner.getClass().getClassLoader(); // Class&lt;?&gt;[] interfaces,被代理对象所实现的所有接口 Class[] interaces= dinner.getClass().getInterfaces(); //InvocationHandler h,执行处理器对象,专门用于定义增强的规则 InvocationHandler handler = new InvocationHandler() &#123; // invoke 当我们让代理对象调用任何方法时,都会触发invoke方法的执行 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //Object proxy, 代理对象 //Method method,被代理的方法 //Object[] args,被代理方法运行时的实参 Object res = null; if (method.getName().equals(&quot;eat&quot;)) &#123; System.out.println(&quot;饭前洗手&quot;); // 让原有的eat的方法去运行 res = method.invoke(dinner, args); System.out.println(&quot;饭后刷碗&quot;); &#125; else &#123; // 如果是其他方法,那么正常执行就可以了 res = method.invoke(dinner, args); &#125; return res; &#125; &#125;; Dinner dinnerProxy =(Dinner) Proxy.newProxyInstance(classLoader,interaces,handler); //dinnerProxy.eat(&quot;包子&quot;); dinnerProxy.drink(); &#125;&#125;interface Dinner&#123; void eat(String foodName); void drink();&#125; class Person implements Dinner&#123; private String name; public Person(String name) &#123; this.name = name; &#125; @Override public void eat(String foodName) &#123; System.out.println(name+&quot;正在吃&quot;+foodName); &#125; @Override public void drink() &#123; System.out.println(name+&quot;正在喝茶&quot;); &#125;&#125; class Student implements Dinner&#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void eat(String foodName) &#123; System.out.println(name+&quot;正在食堂吃&quot;+foodName); &#125; @Override public void drink() &#123; System.out.println(name+&quot;正在喝可乐&quot;); &#125;&#125; ​ 总结： 在不修改原有代码的或者没有办法修改原有代码的情况下，增强对象功能使用代理对象代替原来的对象去完成功能，进而达到拓展功能的目的 JDK Proxy动态代理是面向接口的动态代理，一定要有接口和实现类，代理对象增强的是实现类，在实现接口的方法重写方法，生成的代理对象只能转换成接口，不能转换成代理类 生成的代理对象只能转换成接口，不能转换成被代理类 代理对象只能增强接口中定义的方法，实现类中其他和接口无关的方法是无法增强的 代理对象只能读取到接口中方法上的注解，不能读取到实现类方法上的注解 7.3.2 cglib动态代理模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.testCglib; import org.junit.Test;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy; import java.lang.reflect.Method;/** * @Author: Ly * @Description: */public class Test1 &#123; @Test public void testCglib()&#123; Person person = new Person(); // 获取一个Person的代理对象 // 1 获得一个Enhancer对象 Enhancer enhancer = new Enhancer(); // 2 设置父类字节码 enhancer.setSuperclass(person.getClass()); // 3 获取MethodIntercepter对象 用于定义增强规则 MethodInterceptor methodInterceptor = new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; /* Object o, 生成之后的代理对象 personProxy Method method, 父类中原本要执行的方法 Person&gt;&gt;&gt; eat() Object[] objects, 方法在调用时传入的实参数组 MethodProxy methodProxy 子类中重写父类的方法 personProxy &gt;&gt;&gt; eat() */ Object res = null; if (method.getName().equals(&quot;eat&quot;)) &#123; // 如果是eat方法 则增强并运行 System.out.println(&quot;饭前洗手&quot;); res = methodProxy.invokeSuper(o,objects); System.out.println(&quot;饭后刷碗&quot;); &#125; else &#123; // 如果是其他方法 不增强运行 res = methodProxy.invokeSuper(o,objects); // 子类对象方法在执行,默认会调用父类对应被重写的方法 &#125; return res; &#125; &#125;; // 4 设置methodInterceptor enhancer.setCallback(methodInterceptor); // 5 获得代理对象 Person personProxy = (Person)enhancer.create(); // 6 使用代理对象完成功能 personProxy.eat(&quot;包子&quot;); &#125;&#125;class Person &#123; public Person() &#123; &#125; public void eat(String foodName) &#123; System.out.println(&quot;张三正在吃&quot;+foodName); &#125;&#125; 8、Spring AOP8.1 AOP 概念及原理​ 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。—-【百度百科】 ​ AOP 面向切面编程一般可以在不修改现有代码的情况下，对程序功能进行拓展，往往用于实现日志处理、权限控制、性能检测、事务控制等 ​ AOP实现的原理就是动态代理，在有接口的情况下，使用**JDK动态代理，在没有接口的情况下使用cglib动态代理** 8.2 术语 连接点（Joint point）：类里面可以被增强的方法，这些方法称之为连接点，表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等待，它自身还可以嵌套其他Join point 切入点（Pointcut）：实际被增强的方法，称之为切入点，表示一组joint point，这些joint point或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的Advince将要发生的地方 通知（Advince）：实际增强的逻辑部分称为通知（增加的功能），Advince定义了在Pointcut里面定义的程序点具体要做的操作，它通过before、after、around来区别是在每个joint point之前、之后还是代替执行的代码，通知类型：前置通知、后置通知、环绕通知、异常通知、最终通知 目标对象（Target）：被增强功能的对象（被代理的对象） 切面（Aspect）：表现为功能相关的一些advice放在一起声明成为一个java类，aspect声明类似与java的类声明，在aspect中会包含一些pointcut以及相应的advince 织入（Weaving）：创建代理对象并实现功能增强的声明并运行的过程，将Aspect和其他对象链接起来，并创建Advince Object的过程 8.3 注解方式实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.aspect; import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import java.util.Arrays;/** * @Author: Ly * @Description: */ @Component@Aspectpublic class DaoAspect &#123; //定义公共切点 @Pointcut(&quot;execution(* com.dao.*.add*(..))&quot;) public void addPointCut() &#123;&#125;. /* * 前置通知: 切点方法执行之前先执行的功能 * 参数列表可以用JoinPoint接收切点对象 * 可以获取方法执行的参数 * */ @Before(&quot;addPointCut()&quot;) public void methodBefore(JoinPoint joinPoint) &#123; System.out.println(&quot;Before invoked&quot;); &#125; /* * 后置通知:方法执行之后要增强的功能 * 无论切点方法是否出现异常都会执行的方法 * 参数列表可以用JoinPoint接收切点对象 * */ @After(&quot;addPointCut()&quot;) public void methodAfter(JoinPoint joinPoint) &#123; System.out.println(&quot;After invoked&quot;); &#125; /* * 返回通知:切点方法正常运行结束后增强的功能 * 如果方法运行过程中出现异常,则该功能不运行 * 参数列表可以用 JoinPoint joinPoint接收切点对象 * 可以用Object res接收方法返回值,需要用returning指定返回值名称 * */ @AfterReturning( value = &quot;addPointCut()&quot;,returning = &quot;res&quot;) public void methodAfterReturning(JoinPoint joinPoint, Object res) &#123; System.out.println(&quot;AfterReturning invoked&quot;); &#125; /* * 异常通知:切点方法出现异常时运行的增强功能 * 如果方法运行没有出现异常,则该功能不运行 * 参数列表可以用Exception ex接收异常对象 需要通过throwing指定异常名称 * */ @AfterThrowing( value = &quot;addPointCut()&quot;,throwing = &quot;ex&quot;) public void methodAfterThrowing(Exception ex) &#123; System.out.println(&quot;AfterThrowing invoked&quot;); &#125; /*环绕通知:在切点方法之前和之后都进行功能的增强 * 需要在通知中定义方法执行的位置,并在执行位置之前和之后自定义增强的功能 * 方法列表可以通过ProceedingJoinPoint获取执行的切点 * 通过proceedingJoinPoint.proceed()方法控制切点方法的执行位置 * proceedingJoinPoint.proceed()方法会将切点方法的返回值获取到,并交给我们,可以做后续处理 * 我们在环绕通知的最后需要将切点方法的返回值继续向上返回,否则切点方法在执行时接收不到返回值 * */ @Around(&quot;addPointCut()&quot;) public Object methodAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;aroundA invoked&quot;); Object proceed = proceedingJoinPoint.proceed(); System.out.println(&quot;aroundB invoked&quot;); return proceed; &#125;&#125; ​ 有多个增强类对同一个方法进行增强，通过@Order注解设置增强类优先级，数字越小，优先级越高，数字越小，其代理位置越靠近注入位置 9、Spring 事务9.1 事务​ 事务（Transaction）：指的是一个操作序列，该操作序列中的多个操作，只能都做，或者都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理 ​ 但并不是所有的操作序列都可以称为为事务，因为一个操作序列成为事务，必须满足事务的四个特性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ACID特性 9.1.1 原子性​ 原子是自然界最小的颗粒，具有不可再分的特性。事务中的所有操作可以看做一个原子，事务是应用中不可再分的最小的逻辑执行体。 ​ 使用事务对数据进行修改的操作序列，要么全部执行，要么全不执行。通常，某个事务中的操作都具有共同的目标，并且是相互依赖的。如果数据库系统只执行这些操作中的一部分，则可能会破坏事务的总体目标，而原子性消除了系统只处理部分操作的可能性。 9.1.2 一致性​ 一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。 ​ 例如：在转账时，只有保证转出和转入的金额一致才能构成事务。也就是说事务发生前和发生后，数据的总额依然匹配。 9.1.3 隔离性​ 隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。 ​ 例如：在转账时，只有当A账户中的转出和B账户中转入操作都执行成功后才能看到A账户中的金额减少以及B账户中的金额增多。并且其他的事务对于转账操作的事务是不能产生任何影响的。 9.1.4 持久性​ 持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。 9.2 事务的并发问题9.2.1 脏读（Dirty read）​ 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 9.2.2 不可重复读（Unrepeatableread）​ 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 9.2.3 幻读（Phantom read）​ 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 9.2.4 总结​ 不可重复读的重点是修改，幻读的重点在于新增或者删除 ​ 解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表 9.2.5 事务的隔离级别​ 事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以MySQL中提供了四种隔离级别来解决上述问题。 ​ 事务的隔离级别从低到高依次为READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ以及SERIALIZABLE，隔离级别越低，越能支持高并发的数据库操作。 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED（读未提交） true true true READ COMMITTED（读已提交） false true true REPEATABLE READ（可重复读） false false true SERIALIZABLE（串行化） false false false ​","tags":[{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/note/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Spring","slug":"Spring","permalink":"https://lyblog2022.github.io/note/tags/Spring/"}]},{"title":"Servlet","date":"2022-06-04T08:59:30.000Z","path":"2022/06/04/study/Servlet/","text":"Servlet学习 1、Servlet的继承结构 2、Servlet接口 init()：创建servlet对象后立即调用该方法完成其他初始化工作 service()：处理客户端请求，执行业务操作，利用响应对象响应客户端请求 destory()：再销毁servlet对象之前调用该方法，释放资源 getServletConfig()：ServletConfig 是容器向Servlet传递参数的载体 getServletInfo()：获取servlet相关信息 3、ServletConfig 接口​ Servlet运行期间，需要一些辅助信息，这些信息可以在web.xml文件中，使用一个或多个元素进行配置。当tomacat初始化一个servlet时，会将该servlet的配置信息，封装到ServletConfig对象中，通过调用init(ServletConfig servletConfig)方法，将ServletConfig对象传递给Servlet 4、GenericServlet 抽象类​ GenericServlet是实现了Servlet接口的抽象类。在GenericServlet中进一步的定义了Servlet接口的具体实现，其设计的目的是为了和应用层协议解耦，再GenericServlet中包含了一个Service抽象方法，可以通过继承GenericServlet并实现Service方法实现请求的处理，但是需要将ServletRequest和ServletResponse 转化为HttpServletRequest和HttpServletResponse 5、HttpServlet​ 继承自GenericServlet，针对于处理Http协议的请求定制，在HttpServlet的service()方法中已经把ServletRequest和ServletResponse 转化为HttpServletRequest和HttpServletResponse 6、Servlet的生命周期​ servlet的生命周期是由容器管理的，分别经历4个阶段 阶段 字数 时机 创建 1次 第一次请求之后 初始化 1次 实例化之后 执行服务 多次 每次请求 销毁 1次 停止服务、 7、注意事项 在Servlet中一般不要轻易使用成员变量，可能会造成线程安全问题 如果要使用，应尽量避免对成员变量产生修改 如果要产生修改，应注意线程安全问题 8、ServletContext对象和ServletConfig对象​ ServletContext叫做Servlet上下文，服务器会为每一个web应用创建一个ServletContext对象，这个对象全局唯一，而且web应用中的所有Servlet都共享这个对象 8.1、ServletContext对象的作用 相对路径转为绝对路径 获取容器的附加信息 读取配置 全局容器 8.2、ServletContext的生命周期​ 当容器启动时会创建ServletContext对象并一直缓存该对象，直到容器关闭后该对象生命周期结束，ServletContext的生命周期非常长，所以在使用全局容器时不建议存放业务数据 8.3、ServletConfig对象​ ServletConfig对象对应web.xml文件中的节点，当Tomcat初始化一个Servlet时，会将该Servlet的配置信息，封装到一个ServletConfig对象中，可以通过该对象读取节点中的配置信息 9、请求转发9.1 forward转发9.1.1 forward转发处理流程 清空response存放的正在响应正文数据缓冲区 如果目标资源为Servlet或jsp，就调用他们的service方法，把该方法产生的响应结果发送到客户端；如果目标资源是静态文件中的HTML，就读取文件中的数据把它发送到客户端 9.1.2 forward处理特点 由于forward()方法先清空用于存放相应正文的缓冲区，因此源Servlet生成的响应结果不会被发送到客户端，只有目标资源生成的响应结果才会被发送到客户端 如果源Servlet在进行请求转发之前，已经提交了响应结(flushBuffer()，close()方法)，那么forward()方法会抛出异常，为避免异常，不应该在源servlet中提交响应结果 9.2 include转发9.2.1 include处理流程 如果目标资源为Servlet或者jsp，就调用他们的service方法，把该方法产生的响应正文添加到源Servlet的响应结果中；如果目标组建为HTML文档，就直接把文档的内容添加到源Servlet的响应结果中 返回到源Servlet的服务方法中，继续执行后续代码 9.2.2 include处理特点 源Servlet与被包含的目标资源的输出数据都会被添加到响应结果中 在目标资源对响应状态码或者响应开头所做的修改都会被忽略 10、Cookie对象和HttpSession对象​ Cookie对象和HttpSession对象的作用是维护客户端浏览器与服务端的会话状态的两个对象，二者的不同是Cookie是通过客户端浏览器实现会话的维持，而HttpSession是通过服务端来实现会话的维持 10.1 区别 cookie数据存放在客户的浏览器或系统文件中，httpsession中的数据存放在服务器中 cookie不安全，httpSession是安全的 单个cookie保存的数据不能超过4K，httpSession无限制","tags":[{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/note/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"servlet","slug":"servlet","permalink":"https://lyblog2022.github.io/note/tags/servlet/"}]},{"title":"MyBatis","date":"2022-06-04T08:59:00.000Z","path":"2022/06/04/study/MyBatis/","text":"MyBatis学习 1、简介Mybatis 是一款优秀的持久层框架，支持定制化SQL、存储过程及高级映射，可以使用简单的XML或注解来配置和映射原生信息 是一款半自动的持久层的半自动ORM映射框架 1.1 框架 框架是一个基本概念上的结构，用于解决或处理复杂的问题。 使用框架的优点：减少开发时间，降低开发难度，保证设计质量，降低程序员之间的沟通以及日后维护的成本 框架是一个半成品，已经对基础的代码进行了封装并提供响应的API，开发者再使用框架是直接调用封装好的API，可以省去很多代码编写，从而提升效率和开发速度 1.2 ORM Object-Relation Mapping，对象关系映射 它的作用是在关系型数据库和对象之间做一个映射，这样在操作具体数据的时候就像操作对象一样 1.2.1 持久化 持久：把数据保存到可永久保存的存储设备中 主要应用：将内存中的数据存储在关系型数据库中 1.2.2 持久层 专注于实现数据持久化应用领域的某一个特定系统的一个逻辑层面，将数据使用者和数据实体想关联（mapper层、DAO层） 2、Mybatis配置2.1 事务​ 在MyBatis 核心配置文件中envirment 中通过transactionManager配置事务的处理策略 JDBC：该配置使用了JDBC的提交及回滚，依赖于从数据源得到的链接来管理事务范围 MANAGED：该配置几乎无任何操作，不提交或回滚一个链接，它会让容器来管理整个生命周期（Spring应用服务器的上下文），默认情况下会关闭链接，但一些容器不希望如此，因此如果需要从链接中停止它，将closeConnection的属性值设置为false，Mybatis本身并不会处理事务，而是交给其他框架去处理 2.2 映射文件的加载方式 mapper的映射文件的文件路径导入，使用的是mapper标签的resource属性 网络资源路径使用的是mapper的url属性 接口的全限定名导入使用的是mapper标签的class属性—–基于接口的代理模式 包扫描形式加载所有的mapper映射文件，使用的package标签 3、Mybatis 开发3.1 传递参数 ${} 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置 #{} 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理，更常用 4、MyBatis代理模式开发在MyBatis中提供了一种称为Mapper代理（接口绑定）的操作方式，在实际开发中也使用该方式 4.1 原理浅析​ 底层使用了动态代理模式，动态创建一个Mapper的一个代理对象并赋给接口使用 5、动态SQL​ MyBatis在简化操作方法上提出了动态SQL功能，将使用Java代码拼接SQL语句，改变为在XML映射文件中截止标签拼接SQL语句。相比而言，大大减少代码量，更灵活、有利于后期维护 ​ MyBatis中动态SQL是编写在mapper.xml中的，其语法和JSTL类似，但是却是基于强大的OGNL表达式实现的 ​ MyBatis也可以在注解中配置SQL，但是由于注解功能受限，尤其是对于复杂的SQL语句，可读性很差，所以较少使用 5.1 If标签条件查询，符合if的条件，则补充SQL语句 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mapper.StudentMapper&quot;&gt; &lt;select id=&quot;findByCondition&quot; resultType=&quot;Student&quot;&gt; select * from student where 1=1 &lt;if test=&quot;stuno != null&quot;&gt; and stuno =#&#123;stuno&#125; &lt;/if&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; and classname like concat(&#x27;%&#x27;,#&#123;classname&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; 5.2 Where标签用于处理where关键字和and 1234567891011&lt;select id=&quot;findStuByCondition&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;where&gt; &lt;if test=&quot;stuno != null&quot;&gt; and stuno= #&#123;stuno&#125; &lt;/if&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; and classname= #&#123;classname&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 5.3 Choose标签前面的when条件成立 后面的 when就不再判断了 12345678910111213&lt;select id=&quot;findStuByCondition&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;stuno != null&quot;&gt; and stuno= #&#123;stuno&#125; &lt;/when&gt; &lt;when test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; and classname= #&#123;classname&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 5.4 Set标签12345678910111213&lt;update id=&quot;updateStuByCondtion&quot; &gt; update student &lt;set&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27; &quot;&gt; , classname =#&#123;classname&#125; &lt;/if&gt; &lt;if test=&quot;stuno != null &quot;&gt; , stuname =#&#123;stuname&#125; &lt;/if&gt; &lt;/set&gt; where stuno =#&#123;stuno&#125;&lt;/update&gt; 5.5 Trim标签123456789101112131415161718&lt;update id=&quot;updateStuByCondition&quot; &gt; update student &lt;!--prefix 要增加什么前缀 prefixOverrides 要去除什么前缀 suffix 要增加什么后缀 suffixOverrides 要去除什么后缀 set 是trim的一种特殊情况 --&gt; &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot; &gt; &lt;if test=&quot;stuname != null and stuname != &#x27;&#x27;&quot;&gt; stuname= #&#123;stuname&#125;, &lt;/if&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; classname= #&#123;classname&#125;, &lt;/if&gt; &lt;/trim&gt; where stuno = #&#123;stuno&#125;&lt;/update&gt; 5.6 Bind标签一般用于处理模糊查询的模板 1234&lt;select id=&quot;findStuByClassName&quot; resultType=&quot;Student&quot;&gt; &lt;bind name=&quot;likePattern&quot; value=&quot;&#x27;%&#x27;+param1+&#x27;%&#x27;&quot;&gt;&lt;/bind&gt; select * from student where classname like #&#123;classname&#125;&lt;/select&gt; 6、缓存6.1 一级缓存​ 一级存储是SqlSession上的缓存，默认开启，是一种内存型缓存,不要求实体类对象实现Serializable接口 ​ 缓存中的数据使用键值对形式存储数据 ​ namespace+sqlid+args+offset&gt;&gt;&gt; hash值作为键,查询出的结果作为值 6.2 二级缓存​ 二级缓存是以namespace为标记的缓存，可以是由一个SqlSessionFactory创建的SqlSession之间共享缓存数据。默认并不开启，要求实体类必须实现序列化接口 注意： ​ 1、 MyBatis的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对JavaBean对象实现序列化接口。 ​ 2、二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响 ​ 3、加入Cache元素后，会对相应命名空间所有的select元素查询结果进行缓存，而其中的insert、update、delete在操作是会清空整个namespace的缓存 ​ 4、cache 有一些可选的属性 type, eviction, flushInterval, size, readOnly, blocking。 1&lt;cache type=&quot;&quot; readOnly=&quot;&quot; eviction=&quot;&quot;flushInterval=&quot;&quot;size=&quot;&quot;blocking=&quot;&quot;/&gt; 属性 含义 默认值 type 自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口 null readOnly 是否只读 true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。false:会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全 false eviction 缓存策略LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。FIFO – 先进先出：按对象进入缓存的顺序来移除它们。SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 LRU flushInterval 刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，只有执行update、insert、delete语句才会刷新 null size 缓存对象个数 1024 blocking 是否使用阻塞性缓存BlockingCachetrue：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，否则会在查询数据库以后再释放锁，保证只有一个线程到数据库中查找指定key对应的数据false：不使用阻塞性缓存，性能更好 false ​ 5、如果在加入Cache元素的前提下让个别select 元素不使用缓存，可以使用useCache属性，设置为false。**useCache**控制当前sql语句是否启用缓存 flushCache控制当前sql执行一次后是否刷新缓存 1&lt;select id=&quot;findStuByCondition&quot; resultType=&quot;Student&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt; 6.3 三方缓存+ 分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.`ehcache`,`redis `,`memcache`缓存框架。 + `Ehcache`：是一种广泛使用的开源`java`分布式缓存。主要面向通用缓存，`javaEE `和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式`web application`的","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://lyblog2022.github.io/note/tags/MyBatis/"},{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/note/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"518总结--post请求调用接口","date":"2022-05-18T13:06:35.000Z","path":"2022/05/18/dailysummary/20220518/dailysummary/","text":"使用post方式调用接口并传递参数 方式一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.summary;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import com.alibaba.fastjson.JSONObject;public class Summary &#123; /** * 发送post请求 * @param url：请求URL * @param headerParamsJson：请求header参数 * @param paramJson：请求参数 * @return */ public JSONObject sendData(String url, JSONObject headerParamsJson, JSONObject paramJson) &#123; JSONObject resultJson = new JSONObject(); // 发送post请求 try &#123; HttpPost httppost = new HttpPost(url); RequestConfig defaultRequestConfig = RequestConfig.custom().setConnectTimeout(5000) .setConnectionRequestTimeout(5000).setSocketTimeout(15000).build(); httppost.setConfig(defaultRequestConfig); StringEntity entity = new StringEntity(paramJson.toJSONString(), &quot;utf-8&quot;);// 解决中文乱码问题 entity.setContentEncoding(&quot;UTF-8&quot;); entity.setContentType(&quot;text/json&quot;); httppost.setEntity(entity); httppost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); // 添加header参数 Iterator headerParamsIterator = headerParamsJson.entrySet().iterator(); while (headerParamsIterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) headerParamsIterator.next(); httppost.setHeader(entry.getKey().toString(), entry.getValue().toString()); &#125; // 装填参数 List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); if (paramJson != null) &#123; Iterator iterator = paramJson.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); nvps.add(new BasicNameValuePair((String) entry.getKey(), (String) entry.getValue())); &#125; &#125; UrlEncodedFormEntity reqEntity = new UrlEncodedFormEntity(nvps, &quot;utf-8&quot;); httppost.setEntity(reqEntity); // 执行post请求. CloseableHttpClient httpclient = HttpClients.createDefault(); CloseableHttpResponse response1 = httpclient.execute(httppost); String resultText = &quot;&quot;; try &#123; int statusCode = response1.getStatusLine().getStatusCode(); if (statusCode != 200) &#123; throw new RuntimeException(&quot;请求失败&quot;); &#125; else &#123; // 响应实体 HttpEntity entity2 = response1.getEntity(); if (entity2 != null) &#123; // 响应内容 resultText = EntityUtils.toString(entity2, Charset.forName(&quot;UTF-8&quot;)); resultJson = JSONObject.parseObject(resultText); &#125; &#125; resultJson.put(&quot;code&quot;, statusCode); &#125; finally &#123; response1.close(); &#125; &#125; catch (Exception e) &#123; resultJson.put(&quot;code&quot;, &quot;410&quot;); resultJson.put(&quot;err&quot;, e.toString()); &#125; return resultJson; &#125;&#125;","tags":[{"name":"接口调用","slug":"接口调用","permalink":"https://lyblog2022.github.io/note/tags/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"}]}]