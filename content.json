[{"title":"java并发编程--并发编程的三大特性","date":"2023-01-28T13:41:08.000Z","path":"2023/01/28/study/java/并发编程/并发编程的三大特性/","text":"java并发编程—-并发编程的三大特性 1、原子性1.1 什么是并发编程的原子性 不同的硬件和不同的操作系统在内存上的操作有一定差异的 Java为了解决相同代码在不同操作系统上出现的各种问题，用JMM（Java Memory Model）屏蔽掉各种硬件和操作系统带来的差异。 让Java的并发编程可以做到跨平台。 JMM规定所有变量都会存储在主内存中，在操作的时候，需要从主内存中复制一份到线程内存（CPU内存），在线程内部做计算。然后再写回主内存中（不一定！）。 原子性的定义：原子性指一个操作是不可分割的，不可中断的，一个线程在执行时，另一个线程不会影响到他。 并发编程的原子性用代码阐述： 12345678910111213141516171819202122232425262728private static int count;public static void increment()&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count++;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; increment(); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; increment(); &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count);&#125; 当前程序：多线程操作共享数据时，预期的结果，与最终的结果不符。 原子性：多线程操作临界资源，预期的结果与最终结果一致。 通过对这个程序的分析，可以查看出，++的操作，一共分为了三部，首先是线程从主内存拿到数据保存到CPU的寄存器中，然后在寄存器中进行+1操作，最终将结果写回到主内存当中。 1.2 保证并发编程的原子性1.2.1 synchronized因为++操作可以从指令中查看到 可以在方法上追加synchronized关键字或者采用同步代码块的形式来保证原子性 synchronized可以让避免多线程同时操作临街资源，同一时间点，只会有一个线程正在操作临界资源 1.2.2 CASCAS：compare and swap也就是比较和交换，他是一条CPU的并发原语。 他在替换内存的某个位置的值时，首先查看内存中的值与预期值是否一致，如果一致，执行替换操作。这个操作是一个原子性操作。 Java中基于Unsafe的类提供了对CAS的操作的方法，JVM会帮助我们将方法实现CAS汇编指令。 但是要清楚CAS只是比较和交换，在获取原值的这个操作上，需要你自己实现。 12345678910111213141516171819private static AtomicInteger count = new AtomicInteger(0);public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; count.incrementAndGet(); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; count.incrementAndGet(); &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count);&#125; CAS的缺点：CAS只能保证对一个变量的操作是原子性的，无法实现对多行代码实现原子性。 CAS的问题： ABA问题： 问题如下: 可以引入版本号的方式，来解决ABA的问题。Java中提供了一个类在CAS时，针对各个版本追加版本号的操作。 AtomicStampeReference AtomicStampedReference在CAS时，不但会判断原值，还会比较版本信息。 示例： 123456789101112public static void main(String[] args) &#123; AtomicStampedReference&lt;String&gt; reference = new AtomicStampedReference&lt;&gt;(&quot;AAA&quot;,1); String oldValue = reference.getReference(); int oldVersion = reference.getStamp(); boolean b = reference.compareAndSet(oldValue, &quot;B&quot;, oldVersion, oldVersion + 1); System.out.println(&quot;修改1版本的：&quot; + b +&quot; value:&quot;+reference.getReference()+&quot; version:&quot;+reference.getStamp()); boolean c = reference.compareAndSet(&quot;B&quot;, &quot;C&quot;, 1, 1 + 1); System.out.println(&quot;修改2版本的：&quot; + c+&quot; value:&quot;+reference.getReference()+&quot; version:&quot;+reference.getStamp());&#125; 自旋时间过长问题： 可以指定CAS一共循环多少次，如果超过这个次数，直接失败&#x2F;或者挂起线程。（自旋锁、自适应自旋锁） 可以在CAS一次失败后，将这个操作暂存起来，后面需要获取结果时，将暂存的操作全部执行，再返回最后的结果。 1.2.3 Lock锁实现： 12345678910111213141516171819202122232425262728293031323334353637private static int count;private static ReentrantLock lock = new ReentrantLock();public static void increment(int num) &#123; lock.lock(); try &#123; count+=num; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; increment(i); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; increment(i); &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count);&#125; ReentrantLock可以直接对比synchronized，在功能上来说，都是锁。 但是ReentrantLock的功能性相比synchronized更丰富。 ReentrantLock底层是基于AQS实现的，有一个基于CAS维护的state变量来实现锁的操作。 1.2.4 ThreadLocalThreadLocal保证原子性的方式，是不让多线程去操作临界资源，让每个线程去操作属于自己的数据 123456789101112131415static ThreadLocal tl1 = new ThreadLocal();static ThreadLocal tl2 = new ThreadLocal();public static void main(String[] args) &#123; tl1.set(&quot;123&quot;); tl2.set(&quot;456&quot;); Thread t1 = new Thread(() -&gt; &#123; System.out.println(&quot;t1-t1:&quot; + tl1.get()); System.out.println(&quot;t10t2:&quot; + tl2.get()); &#125;); t1.start(); System.out.println(&quot;main-t1:&quot; + tl1.get()); System.out.println(&quot;main-t2:&quot; + tl2.get());&#125; ThreadLocal实现原理： 每个Thread中都存储着一个成员变量，ThreadLocalMap ThreadLocal本身不存储数据，像是一个工具类，基于ThreadLocal去操作ThreadLocalMap ThreadLocalMap本身就是基于Entry[]实现的，因为一个线程可以绑定多个ThreadLocal，这样一来，可能需要存储多个数据，所以采用Entry[]的形式实现。 每一个线程都自己独立的ThreadLocalMap，再基于ThreadLocal对象本身作为key，对value进行存取 ThreadLocalMap的key是一个弱引用，弱引用的特点是，即便有弱引用，在GC时，也必须被回收。这里是为了在ThreadLocal对象失去引用后，如果key的引用是强引用，会导致ThreadLocal对象无法被回收 ThreadLocal内存泄漏问题： 如果ThreadLocal引用丢失，key因为弱引用会被GC回收掉，如果同时线程还没有被回收，就会导致内存泄漏，内存中的value无法被回收，同时也无法被获取到。 只需要在使用完毕ThreadLocal对象之后，及时的调用remove方法，移除Entry即可 2、可见性2.1 什么是可见性可见性问题是基于CPU位置出现的，CPU处理速度非常快，相对CPU来说，去主内存获取数据这个事情太慢了，CPU就提供了L1，L2，L3的三级缓存，每次去主内存拿完数据后，就会存储到CPU的三级缓存，每次去三级缓存拿数据，效率肯定会提升。 这就带来了问题，现在CPU都是多核，每个线程的工作内存（CPU三级缓存）都是独立的，会告知每个线程中做修改时，只改自己的工作内存，没有及时的同步到主内存，导致数据不一致问题。 可见性问题的代码逻辑 123456789101112131415private static boolean flag = true;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while (flag) &#123; // .... &#125; System.out.println(&quot;t1线程结束&quot;); &#125;); t1.start(); Thread.sleep(10); flag = false; System.out.println(&quot;主线程将flag改为false&quot;);&#125; 2.2 解决可见性的方式2.2.1 volatilevolatile是一个关键字，用来修饰成员变量。 如果属性被volatile修饰，相当于会告诉CPU，对当前属性的操作，不允许使用CPU的缓存，必须去和主内存操作 volatile的内存语义： + volatile属性被写：当写一个volatile变量，JMM会将当前线程对应的CPU缓存及时的刷新到主内存中 + volatile属性被读：当读一个volatile变量，JMM会将对应的CPU缓存中的内存设置为无效，必须去主内存中重新读取共享变量 其实加了volatile就是告知CPU，对当前属性的读写操作，不允许使用CPU缓存，加了volatile修饰的属性，会在转为汇编之后后，追加一个lock的前缀，CPU执行这个指令时，如果带有lock前缀会做两个事情： + 将当前处理器缓存行的数据写回到主内存 + 这个写回的数据，在其他的CPU内核的缓存中，直接无效。 总结：volatile就是让CPU每次操作这个数据时，必须立即同步到主内存，以及从主内存读取数据。 123456789101112131415private volatile static boolean flag = true;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while (flag) &#123; // .... &#125; System.out.println(&quot;t1线程结束&quot;); &#125;); t1.start(); Thread.sleep(10); flag = false; System.out.println(&quot;主线程将flag改为false&quot;);&#125; 2.2.2 synchronized如果涉及到了synchronized的同步代码块或者是同步方法，获取锁资源之后，将内部涉及到的变量从CPU缓存中移除，必须去主内存中重新拿数据，而且在释放锁之后，会立即将CPU缓存中的数据同步到主内存。 12345678910111213141516171819private static boolean flag = true;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while (flag) &#123; synchronized (MyThread.class)&#123; //... &#125; System.out.println(111); &#125; System.out.println(&quot;t1线程结束&quot;); &#125;); t1.start(); Thread.sleep(10); flag = false; System.out.println(&quot;主线程将flag改为false&quot;);&#125; 2.2.3 LockLock锁保证可见性的方式和synchronized完全不同，synchronized基于他的内存语义，在获取锁和释放锁时，对CPU缓存做一个同步到主内存的操作。 Lock锁是基于volatile实现的。Lock锁内部再进行加锁和释放锁时，会对一个由volatile修饰的state属性进行加减操作。 如果对volatile修饰的属性进行写操作，CPU会执行带有lock前缀的指令，CPU会将修改的数据，从CPU缓存立即同步到主内存，同时也会将其他的属性也立即同步到主内存中。还会将其他CPU缓存行中的这个数据设置为无效，必须重新从主内存中拉取。 12345678910111213141516171819202122private static boolean flag = true;private static Lock lock = new ReentrantLock();public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while (flag) &#123; lock.lock(); try&#123; //... &#125;finally &#123; lock.unlock(); &#125; &#125; System.out.println(&quot;t1线程结束&quot;); &#125;); t1.start(); Thread.sleep(10); flag = false; System.out.println(&quot;主线程将flag改为false&quot;);&#125; 2.2.4 finalfinal修饰的属性，在运行期间是不允许修改的，这样一来，就间接的保证了可见性，所有多线程读取final属性，值肯定是一样。 final并不是说每次取数据从主内存读取，他没有这个必要，而且final和volatile是不允许同时修饰一个属性的 final修饰的内容已经不允许再次被写了，而volatile是保证每次读写数据去主内存读取，并且volatile会影响一定的性能，就不需要同时修饰。 3、有序性3.1 什么是有序性在Java中，.java文件中的内容会被编译，在执行前需要再次转为CPU可以识别的指令，CPU在执行这些指令时，为了提升执行效率，在不影响最终结果的前提下（满足一些要求），会对指令进行重排。 指令乱序执行的原因，是为了尽可能的发挥CPU的性能。 Java中的程序是乱序执行的。 Java程序验证乱序执行效果： 12345678910111213141516171819202122232425262728static int a,b,x,y;public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; a = 0; b = 0; x = 0; y = 0; Thread t1 = new Thread(() -&gt; &#123; a = 1; x = b; &#125;); Thread t2 = new Thread(() -&gt; &#123; b = 1; y = a; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); if(x == 0 &amp;&amp; y == 0)&#123; System.out.println(&quot;第&quot; + i + &quot;次，x = &quot;+ x + &quot;,y = &quot; + y); &#125; &#125;&#125; 单例模式由于指令重排序可能会出现问题： 线程可能会拿到没有初始化的对象，导致在使用时，可能由于内部属性为默认值，导致出现一些不必要的问题 3.2 解决指令重排问题3.2.1 as-if-serialas-if-serial语义： 不论指定如何重排序，需要保证单线程的程序执行结果是不变的。 而且如果存在依赖的关系，那么也不可以做指令重排。 123456789// 这种情况肯定不能做指令重排序int i = 0;i++;// 这种情况肯定不能做指令重排序int j = 200;j * 100;j + 100;// 这里即便出现了指令重排，也不可以影响最终的结果，20100 3.2.2 happens-before具体规则： 单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。 volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作。 happen-before的传递性原则： 如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。 JMM只有在不出现上述8中情况时，才不会触发指令重排效果。 不需要过分的关注happens-before原则，只需要可以写出线程安全的代码就可以了。 3.2.3 volatile如果需要让程序对某一个属性的操作不出现指令重排，除了满足happens-before原则之外，还可以基于volatile修饰属性，从而对这个属性的操作，就不会出现指令重排的问题了。 volatile如何实现的禁止指令重排？ 内存屏障概念。将内存屏障看成一条指令。 会在两个操作之间，添加上一道指令，这个指令就可以避免上下执行的其他指令进行重排序。","tags":[{"name":"java","slug":"java","permalink":"https://lyblog2022.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://lyblog2022.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"java并发编程--线程","date":"2022-12-26T03:06:21.000Z","path":"2022/12/26/study/java/并发编程/线程/","text":"java并发编程—-线程的基础概念 1、基础概念1.1 进程与线程 进程：进程是指运行中的程序。 比如我们使用微信，浏览器，需要启动这个程序，操作系统会给这个程序分配一定的资源（占用内存资源）。 线程：线程是CPU调度的基本单位，每个线程执行的都是某一个进程的代码的某个片段。 举个栗子：房子与人 比如现在有一个100平的房子，这个方式可以看做是一个进程 房子里有人，人就可以看做成一个线程。 人在房子中做一个事情，比如吃饭，学习，睡觉。这个就好像线程在执行某个功能的代码。 所谓进程就是线程的容器，需要线程利用进程中的一些资源，处理一个代码、指令。最终实现进程锁预期的结果。 进程和线程的区别： 根本不同：进程是操作系统分配的资源，而线程是CPU调度的基本单位。 资源方面：同一个进程下的线程共享进程中的一些资源。线程同时拥有自身的独立存储空间。进程之间的资源通常是独立的。 数量不同：进程一般指的就是一个进程。而线程是依附于某个进程的，而且一个进程中至少会有一个或多个线程。 开销不同：毕竟进程和线程不是一个级别的内容，线程的创建和终止的时间是比较短的。而且线程之间的切换比进程之间的切换速度要快很多。而且进程之间的通讯很麻烦，一般要借助内核才可以实现，而线程之间通讯，相当方面。 1.2 多线程多线程是指：单个进程中同时运行多个线程。 使用多线程的目的：为了提高CPU的利用率。可以通过避免一些网络IO或者磁盘IO等需要等待的操作，让CPU去调度其他线程。这样可以大幅度的提升程序的效率，提高用户的体验。 局限： 如果线程数量特别多，CPU在切换线程上下文时，会额外造成很大的消耗。 任务的拆分需要依赖业务场景，有一些异构化的任务，很难对任务拆分，还有很多业务并不是多线程处理更好。 线程安全问题：虽然多线程带来了一定的性能提升，但是再做一些操作时，多线程如果操作临界资源，可能会发生一些数据不一致的安全问题，甚至涉及到锁操作时，会造成死锁问题。 1.3 串行、并行、并发串行： ​ 串行就是一个一个排队，第一个做完，第二个才能上。 并行： ​ 并行就是同时处理。（一起上！！！） 并发： ​ 这里的并发并不是三高中的高并发问题，这里是多线程中的并发概念（CPU调度线程的概念）。CPU在极短的时间内，反复切换执行不同的线程，看似好像是并行，但是只是CPU高速的切换。 并行包括并发 并行就是多核CPU同时调度多个线程，是真正的多个线程同时执行。 单核CPU无法实现并行效果，单核CPU是并发。 1.4 同步异步、阻塞非阻塞同步与异步：执行某个功能后，被调用者是否会主动反馈信息 阻塞和非阻塞：执行某个功能后，调用者是否需要一直等待结果的反馈。 两个概念看似相似，但是侧重点是完全不一样的。 同步阻塞：比如用锅烧水，水开后，不会主动通知你。烧水开始执行后，需要一直等待水烧开。 同步非阻塞：比如用锅烧水，水开后，不会主动通知你。烧水开始执行后，不需要一直等待水烧开，可以去执行其他功能，但是需要时不时的查看水开了没。 异步阻塞：比如用水壶烧水，水开后，会主动通知你水烧开了。烧水开始执行后，需要一直等待水烧开。 异步非阻塞：比如用水壶烧水，水开后，会主动通知你水烧开了。烧水开始执行后，不需要一直等待水烧开，可以去执行其他功能。 异步非阻塞这个效果是最好的，平时开发时，提升效率最好的方式就是采用异步非阻塞的方式处理一些多线程的任务。 2、线程的创建线程的创建分为三种方式 2.1 集成Thread类，重写run方法启动线程是调用start方法，这样会创建一个新的线程，并执行线程的任务。 如果直接调用run方法，这样会让当前线程执行run方法中的业务逻辑。 1234567891011121314151617181920212223242526package com.thread;/** * @description: * @author: ly * @create: 2022-12-26 11:21 * @version: 1.0 **/public class MyThread &#123; public static void main(String[] args) &#123; Slave slave = new Slave(); slave.start(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;main:&quot;+i); &#125; &#125;&#125;class Slave extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;Slave:&quot;+i); &#125; &#125;&#125; 2.2 实现Runnable接口，重写run方法123456789101112131415161718192021222324252627package com.thread;/** * @description: * @author: ly * @create: 2022-12-26 11:21 * @version: 1.0 **/public class MyThread &#123; public static void main(String[] args) &#123; Slave slave = new Slave(); Thread thread = new Thread(slave); thread.start(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;main:&quot;+i); &#125; &#125;&#125;class Slave implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;Slave:&quot;+i); &#125; &#125;&#125; 常用的方式： 匿名内部类 12345678Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;匿名内部类&quot;+i); &#125; &#125; &#125;); lambda 12345Thread thread2 = new Thread(()-&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;lambda&quot;+i); &#125; &#125;); 2.3 实现Callable重写call方法，配合FutrueTaskCallable一般用于有返回结果的同步非阻塞的执行方法 12345678910111213141516171819202122232425262728293031323334package com.thread;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @description: * @author: ly * @create: 2022-12-26 11:21 * @version: 1.0 **/public class MyThread &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; Slave slave = new Slave(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(slave); Thread thread = new Thread(futureTask); thread.start(); Integer count = futureTask.get(); System.out.println(count); &#125;&#125;class Slave implements Callable &#123; @Override public Integer call() throws Exception &#123; int count=0; for (int i = 0; i &lt; 100; i++) &#123; count+=i; &#125; return count; &#125;&#125; 3、线程的基本使用3.1 线程状态java中的线程状态 NEW：Thread对象被创建出来了，但是还没有执行start方法。 RUNNABLE：Thread对象调用了start方法，就为RUNNABLE状态（CPU调度&#x2F;没有调度） BLOCKED、WAITING、TIME_WAITING：都可以理解为是阻塞、等待状态，因为处在这三种状态下，CPU不会调度当前线程 BLOCKED：synchronized没有拿到同步锁，被阻塞的情况 WAITING：调用wait方法就会处于WAITING状态，需要被手动唤醒 TIME_WAITING：调用sleep方法或者join方法，会被自动唤醒，无需手动唤醒 TERMINATED：run方法执行完毕，线程生命周期到头了 代码验证： NEW: 123456public static void main(String[] args) &#123; Thread thread = new Thread(()-&gt;&#123; &#125;); System.out.println(thread.getState());&#125; RUNNABLE: 12345678910public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; while(true)&#123; &#125; &#125;); thread.start(); Thread.sleep(500); System.out.println(thread.getState());&#125; BLOCKED： 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Object obj = new Object(); Thread thread = new Thread(()-&gt;&#123; synchronized (obj)&#123; &#125; &#125;); synchronized (obj)&#123; thread.start(); Thread.sleep(500); System.out.println(thread.getState()); &#125;&#125; WAITING: 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; Object obj = new Object(); Thread thread = new Thread(()-&gt;&#123; synchronized (obj)&#123; try &#123; obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); Thread.sleep(500); System.out.println(thread.getState());&#125; TIMED_WAITING： 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Object obj = new Object(); Thread thread = new Thread(()-&gt;&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); thread.start(); Thread.sleep(500); System.out.println(thread.getState());&#125; TERMINATED: 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Object obj = new Object(); Thread thread = new Thread(()-&gt;&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); thread.start(); Thread.sleep(500); System.out.println(thread.getState());&#125; 3.2 线程常用的方法3.2.1 获取当前线程Thread的静态方法获取当前线程对象 123456public static void main(String[] args) throws InterruptedException &#123; Thread thread = Thread.currentThread(); System.out.println(thread); // &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; + group.getName() + &quot;]&quot;; // Thread[main,5,main]&#125; 3.2.2 获取线程的名称在构建Thread对象完毕后，一定要设置一个有意义的名称，方面后期排查错误 1234567public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()); &#125;); thread.setName(&quot;demo1&quot;); thread.start();&#125; 3.2.3 设置线程优先级其实就是CPU调度线程的优先级 java中给线程设置的优先级别有10个级别，从1~10任取一个整数。 如果超出这个范围，会排除参数异常的错误 12345678910111213141516public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;t1:&quot; + i); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;t2:&quot; + i); &#125; &#125;); t1.setPriority(1); t2.setPriority(10); t2.start(); t1.start();&#125; 3.2.4 线程的让步可以通过Thread的静态方法yield，让当前线程从运行状态转变为就绪状态。 1234567891011121314151617public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i==50) &#123; Thread.yield(); &#125; System.out.println(&quot;t1:&quot; + i); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;t2:&quot; + i); &#125; &#125;); t2.start(); t1.start();&#125; 3.2.5 线程的休眠Thread的静态方法，让线程从运行状态转变为等待状态 sleep有两个方法重载： 第一个就是native修饰的，让线程转为等待状态的效果 第二个是可以传入毫秒和一个纳秒的方法（如果纳秒值大于等于0.5毫秒，就给休眠的毫秒值+1。如果传入的毫秒值是0，纳秒值不为0，就休眠1毫秒） sleep会抛出一个InterruptedException 12345public static void main(String[] args) throws InterruptedException &#123; System.out.println(System.currentTimeMillis()); Thread.sleep(1000); System.out.println(System.currentTimeMillis());&#125; 3.2.6 线程的强占Thread的非静态方法join方法 需要在某一个线程下去调用这个方法 如果在main线程中调用了t1.join()，那么main线程会进入到等待状态，需要等待t1线程全部执行完毕，在恢复到就绪状态等待CPU调度 如果在main线程中调用了t1.join(2000)，那么main线程会进入到等待状态，需要等待t1执行2s后，在恢复到就绪状态等待CPU调度。如果在等待期间，t1已经结束了，那么main线程自动变为就绪状态等待CPU调度。 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;t1:&quot; + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.start(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;main:&quot;+i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (i==1) &#123; try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.2.7 守护线程默认情况下，线程都是非守护线程 JVM会在程序中没有非守护线程时，结束掉当前JVM 主线程默认是非守护线程，如果主线程执行结束，需要查看当前JVM内是否还有非守护线程，如果没有JVM直接停止 123456789101112131415public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;t1:&quot; + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.setDaemon(true); t1.start();&#125; 3.2.8 线程的等待和唤醒可以让获取synchronized锁资源的线程通过wait方法进去到锁的等待池，并且会释放锁资源 可以让获取synchronized锁资源的线程，通过notify或者notifyAll方法，将等待池中的线程唤醒，添加到锁池中 notify随机的唤醒等待池中的一个线程到锁池 notifyAll将等待池中的全部线程都唤醒，并且添加到锁池 在调用wait方法和notify以及norifyAll方法时，必须在synchronized修饰的代码块或者方法内部才可以，因为要操作基于某个对象的锁的信息维护。 1234567891011121314151617181920212223242526272829public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; sync(); &#125;,&quot;t1&quot;); Thread t2 = new Thread(() -&gt; &#123; sync(); &#125;,&quot;t2&quot;); t1.start(); t2.start(); Thread.sleep(2000); synchronized (MyThread.class)&#123; MyThread.class.notifyAll(); &#125;&#125;public static synchronized void sync() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 5) &#123; MyThread.class.wait(); &#125; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 3.3 线程结束方式线程结束方式很多，最常用就是让线程的run方法结束，无论是return结束，还是抛出异常结束，都可以 3.3.1 stop方法（不用）强制让线程结束，不推荐使用当然当然方式，但是，他确实可以把线程干掉 12345678910111213public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); t1.start(); Thread.sleep(500); t1.stop(); System.out.println(t1.getState());&#125; 3.3.2 使用共享变量（很少用）这种方式用的也不多，有的线程可能会通过死循环来保证一直运行。 咱们可以通过修改共享变量在破坏死循环，让线程退出循环，结束run方法 12345678910111213static volatile boolean flag = true;public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while(flag)&#123; System.out.println(&quot;任务处理中&quot;); &#125; System.out.println(&quot;任务结束&quot;); &#125;); t1.start(); Thread.sleep(500); flag = false;&#125; 3.3.3 interrupt方式中断标记位 1234567891011121314151617181920212223public static void main(String[] args) throws InterruptedException &#123; // 线程默认情况下， interrupt标记位：false System.out.println(Thread.currentThread().isInterrupted()); // 执行interrupt之后，再次查看打断信息 Thread.currentThread().interrupt(); // interrupt标记位：ture System.out.println(Thread.currentThread().isInterrupted()); // 返回当前线程，并归位为false interrupt标记位：ture System.out.println(Thread.interrupted()); // 已经归位了 System.out.println(Thread.interrupted()); // ============================= Thread t1 = new Thread(() -&gt; &#123; while(!Thread.currentThread().isInterrupted())&#123; System.out.println(&quot;t1执行&quot;) &#125; System.out.println(&quot;t1结束&quot;); &#125;); t1.start(); Thread.sleep(500); t1.interrupt();&#125; 通过打断WAITING或者TIMED_WAITING状态的线程，从而抛出异常自行处理 这种停止线程方式是最常用的一种，在框架和JUC中也是最常见的 12345678910111213141516171819public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; while(true)&#123; // 获取任务 // 拿到任务，执行任务 // 没有任务了，让线程休眠 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println(&quot;基于打断形式结束当前线程&quot;); return; &#125; &#125; &#125;); t1.start(); Thread.sleep(500); t1.interrupt();&#125;","tags":[{"name":"java","slug":"java","permalink":"https://lyblog2022.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://lyblog2022.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"通过URL下载文件","date":"2022-10-30T04:27:27.000Z","path":"2022/10/30/summary/20221030/通过URL下载文件/","text":"java通过URL下载文件到本地 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 从网络Url中下载文件 * * @param urlStr * @param fileName * @param savePath * @throws IOException */ public static void downLoadFromUrl(String urlStr, String fileName, String savePath) throws IOException &#123; URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //设置超时间为3秒 conn.setConnectTimeout(3 * 1000); //防止屏蔽程序抓取而返回403错误 conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;); //得到输入流 InputStream inputStream = conn.getInputStream(); //获取自己数组 byte[] getData = readInputStream(inputStream); //文件保存位置 File saveDir = new File(savePath); if (!saveDir.exists()) &#123; saveDir.mkdir(); &#125; File file = new File(saveDir + File.separator + fileName); FileOutputStream fos = new FileOutputStream(file); fos.write(getData); if (fos != null) &#123; fos.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; System.out.println(&quot;info:&quot; + url + &quot; download success&quot;); &#125; /** * 从输入流中获取字节数组 * * @param inputStream * @return * @throws IOException */ public static byte[] readInputStream(InputStream inputStream) throws IOException &#123; byte[] buffer = new byte[1024]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((len = inputStream.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; bos.close(); return bos.toByteArray(); &#125; public static void main(String[] args) &#123; try &#123; downLoadFromUrl(&quot;https://dss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/topnav/newfanyi-da0cea8f7e.png&quot;, &quot;百度.png&quot;, &quot;E:\\\\&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;","tags":[]},{"title":"使用post方式调用接口并传递参数","date":"2022-05-18T13:06:35.000Z","path":"2022/05/18/summary/20220518/使用post方式调用接口并传递参数/","text":"使用post方式调用接口并传递参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.summary;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import com.alibaba.fastjson.JSONObject;public class Summary &#123; /** * 发送post请求 * @param url：请求URL * @param headerParamsJson：请求header参数 * @param paramJson：请求参数 * @return */ public JSONObject sendData(String url, JSONObject headerParamsJson, JSONObject paramJson) &#123; JSONObject resultJson = new JSONObject(); // 发送post请求 try &#123; HttpPost httppost = new HttpPost(url); RequestConfig defaultRequestConfig = RequestConfig.custom().setConnectTimeout(5000) .setConnectionRequestTimeout(5000).setSocketTimeout(15000).build(); httppost.setConfig(defaultRequestConfig); StringEntity entity = new StringEntity(paramJson.toJSONString(), &quot;utf-8&quot;);// 解决中文乱码问题 entity.setContentEncoding(&quot;UTF-8&quot;); entity.setContentType(&quot;text/json&quot;); httppost.setEntity(entity); httppost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); // 添加header参数 Iterator headerParamsIterator = headerParamsJson.entrySet().iterator(); while (headerParamsIterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) headerParamsIterator.next(); httppost.setHeader(entry.getKey().toString(), entry.getValue().toString()); &#125; // 装填参数 List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); if (paramJson != null) &#123; Iterator iterator = paramJson.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); nvps.add(new BasicNameValuePair((String) entry.getKey(), (String) entry.getValue())); &#125; &#125; UrlEncodedFormEntity reqEntity = new UrlEncodedFormEntity(nvps, &quot;utf-8&quot;); httppost.setEntity(reqEntity); // 执行post请求. CloseableHttpClient httpclient = HttpClients.createDefault(); CloseableHttpResponse response1 = httpclient.execute(httppost); String resultText = &quot;&quot;; try &#123; int statusCode = response1.getStatusLine().getStatusCode(); if (statusCode != 200) &#123; throw new RuntimeException(&quot;请求失败&quot;); &#125; else &#123; // 响应实体 HttpEntity entity2 = response1.getEntity(); if (entity2 != null) &#123; // 响应内容 resultText = EntityUtils.toString(entity2, Charset.forName(&quot;UTF-8&quot;)); resultJson = JSONObject.parseObject(resultText); &#125; &#125; resultJson.put(&quot;code&quot;, statusCode); &#125; finally &#123; response1.close(); &#125; &#125; catch (Exception e) &#123; resultJson.put(&quot;code&quot;, &quot;410&quot;); resultJson.put(&quot;err&quot;, e.toString()); &#125; return resultJson; &#125;&#125;","tags":[{"name":"httpClient","slug":"httpClient","permalink":"https://lyblog2022.github.io/tags/httpClient/"},{"name":"接口调用","slug":"接口调用","permalink":"https://lyblog2022.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"}]}]