[{"title":"Spring","date":"2022-06-04T08:59:55.000Z","path":"2022/06/04/study/Spring/","text":"Spring学习 1、Spring框架1.1 Spring框架​ Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ​ —-百度百科 目的：解决企业应用开发的复杂性 功能：使用基本的JavaBean代替EJB，并提供更对的企业应用功能 范围：任何Java应用 ​ Spring是分层的全栈式的轻量级开发框架，以IOC和AOP为核心 1.2 优点 方便解耦，简化开发 Spring通过容器，将对象的创建从代码中剥离出来，交给Spring控制，避免直接编码造成模块之间的耦合度高，用户也不必自己编码处理对象的单例和多例控制，主要关注接口功能即可，不用关注具体使用哪个实现类和实现细节问题 AOP切面编程 AOP切面编程是程序设计的一种概念，Spring对该概念实现的比较好，通过切面编程我们可以在不修改原有代码的情况下实现功能的增加，通常用于事务控制、日志记录、性能检测、权限控制等等 声明式事务 事务的控制可以托管给Spring，我们通过注解或者配置文件声明事务的处理方式即可，不用我们自己去编码处理 整合JUNIT，方便测试 spring整合JUNIT单元测试，对于项目的功能都可以进行轻松快速的测试，便于我们调试程序 方便整合各种优秀的框架 丰富的功能封装 spring对JAVAEE(JDBC ，JAVAMail)都进行了一系列的封装，简化我们对于API的使用，提高程序的开发效率 规范的源码学习样本 spring的源码设计巧妙，结构清晰，大量使用了设计模式，是java代码规范编写的典范 2、Spring模块 2.1 Data Access/Integration（数据访问／集成）数据访问&#x2F;集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块 JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了在开发过程中对数据库操作的编码。 ORM 模块：对流行的对象关系映射 API，包括 JPA、JDO、Hibernate和 iBatis 提供了的集成层。 OXM 模块：提供了一个支持对象XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。 JMS 模块：指JAVA消息服务，包含的功能为生产和消费的信息。 Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。 2.2 Web 模块Spring 的 Web 层包括 Web、Servlet、Struts 和 Portlet 组件 Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。 Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web应用程序。 Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。 Portlet 模块：提供了在 Portlet 环境中使用 MVC实现，类似 Web-Servlet 模块的功能。 2.3 Core Container（核心容器）Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成 Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。 Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。 Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。 Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。 2.4 其他模块Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块 AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。 Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。 Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。 Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。 3、Spring_IOC3.1 控制反转​ 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫依赖查找（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。–【百度】 ​ 简单来说，创建对象的权利，或者是控制的位置，由Java代码转移到Spring容器，由Spring的容器控制对象的创建，就是控制反转，Spring创建对象时，会读取配置文件中的信息，然后使用反射创建好的对象之后在容器中存储起来，当需要某个对象时，通过id获取对象即可，不需要自己去new 3.2 原理分析3.2.1 XML解析1&lt;bean id=&quot;stuDao&quot; class=&quot;com.dao.impl.StuDaoImpl&quot;&gt;&lt;/bean&gt; ​ 将上面的信息读取进入程序 对象的ID ,一个是对象的类的全路径名 3.2.2 反射123456//获得类的字节码Class clazz =Class.forName(&quot;com.dao.impl.StuDaoImpl&quot;);//通过字节码实例化对象Object obj = clazz.newInstance(); //将对象放到一个map集合中map.put(&quot;empDao&quot;,obj) 3.2.3 工厂模式1234public Object getBean(String name)&#123; Object obj =map.get(name); return obj; &#125; IOC接口 + `BeanFactory `接口：`IOC`容器基本功能接口，是`spring`内部使用的接口，我们在处理业务时一般不直接使用该接口 + `ApplicationContext `接口：`BeanFactory`的子接口，提供更多更强大的功能，研发人员一般使用的接口 4、Spring_XML方式实现DIspring中的Bean的管理: Bean(汉译咖啡豆)，又称JAVABean，其实就是JAVA程序程序中的一个个对象，所以Bean的管理其实就是spring对于JAVA程序中的对象的管理 管理的内容 + 对象的创建（`IOC`）：控制反转，就是`Spring`给我们创建对象，然后我们直接用，不用自己`NEW` + 属性的赋值（`DI`）：依赖注入，即创建属性时给对象属性赋值，对象功能的实现往往要依赖属性的值，由于对象属性不仅仅是基本数据类型，还可能是其他类或者引用类型，那么依赖注入将会把更多的对象之间的关系整理到一起，可以形成一个庞大的依赖关系，DI处理的是对象的属性赋值和互相依赖的关系 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--通过无参构造方法构造对象--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.bean.User&quot; name=&quot;user1&quot; scope=&quot;prototype&quot; lazy-init=&quot;true&quot;&gt;&lt;/bean&gt;&lt;!--id:对象的idclass:类的全路径名name:和id类似,一般不用scope：控制对象单例多例和使用范围 singleton：作用域(scope 默认值), Spring IOC容器中只会存在一个共享的bean实例 prototype：作用域部署的bean，每一次获取都会产生一个新的bean实例，相当与一个new的操作 request：表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 session：作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效 global session：作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义lazy-init：懒加载 调用getBean的时候再去实例化对象--&gt;&lt;!--通过set方法给对象属性赋值--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.bean.User&quot;&gt; &lt;property name=&quot;userid&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;abcdefg&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--通过有参构造给对象属性赋值--&gt;&lt;bean id=&quot;user2&quot; class=&quot;com.msb.bean.User&quot;&gt; &lt;constructor-arg name=&quot;userid&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;小明&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;password&quot; value=&quot;123456789&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--特殊符号--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.msb.bean.User&quot;&gt; &lt;!--null值--&gt; &lt;property name=&quot;userid&quot;&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;!--特殊符号 转译字符 &lt; &amp;lt; &gt;&amp;gt; &amp; &amp;amp; --&gt; &lt;property name=&quot;username&quot; value=&quot;&amp;amp;xiaoming&amp;lt;&amp;gt;&quot;&gt;&lt;/property&gt; &lt;!-- 特殊符号 &lt;![CDATA[内容]]&gt; --&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;&lt;![CDATA[&amp;&lt;123456&gt;]]&gt;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 5、Spring_Bean生命周期 1. 通过构造器创建bean实例======== 执行构造器 2. 为bean属性赋值=============== 执行set方法 3. 初始化bean=================== 调用bean的初始化方法,需要配置指定调用的方法 4. bean的获取=================== 容器对象 getBean方法 5. 容器关闭销毁bean============== 调用销毁方法,需要配置指定调用的方法 6、Spring注解方式管理Bean6.1 注解方式创建对象IOC+ @Component：放在类上,用于标记，告诉`spring`当前类需要由容器实例化`bean`并放入容器中 + @Controller：@Component子注解，用于实例化`controller`层`bean` + @Service：@Component子注解，用于实例化`service`层`bean` + @Repository：@Component子注解，用于实例化持久层`bean` 6.2 注解方式依赖注入DI+ @Autowired：根据属性数据类型自动装配 + @Qualifier：根据属性名称注入依赖 + @Resources：可以根据类型,也可以根据名称注入 + @Value：注入普通数据类型(8+String) 7、Spring代理","tags":[{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/note/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Spring","slug":"Spring","permalink":"https://lyblog2022.github.io/note/tags/Spring/"}]},{"title":"Servlet","date":"2022-06-04T08:59:30.000Z","path":"2022/06/04/study/Servlet/","text":"Servlet学习 1、Servlet的继承结构 2、Servlet接口 init()：创建servlet对象后立即调用该方法完成其他初始化工作 service()：处理客户端请求，执行业务操作，利用响应对象响应客户端请求 destory()：再销毁servlet对象之前调用该方法，释放资源 getServletConfig()：ServletConfig 是容器向Servlet传递参数的载体 getServletInfo()：获取servlet相关信息 3、ServletConfig 接口​ Servlet运行期间，需要一些辅助信息，这些信息可以在web.xml文件中，使用一个或多个元素进行配置。当tomacat初始化一个servlet时，会将该servlet的配置信息，封装到ServletConfig对象中，通过调用init(ServletConfig servletConfig)方法，将ServletConfig对象传递给Servlet 4、GenericServlet 抽象类​ GenericServlet是实现了Servlet接口的抽象类。在GenericServlet中进一步的定义了Servlet接口的具体实现，其设计的目的是为了和应用层协议解耦，再GenericServlet中包含了一个Service抽象方法，可以通过继承GenericServlet并实现Service方法实现请求的处理，但是需要将ServletRequest和ServletResponse 转化为HttpServletRequest和HttpServletResponse 5、HttpServlet​ 继承自GenericServlet，针对于处理Http协议的请求定制，在HttpServlet的service()方法中已经把ServletRequest和ServletResponse 转化为HttpServletRequest和HttpServletResponse 6、Servlet的生命周期​ servlet的生命周期是由容器管理的，分别经历4个阶段 阶段 字数 时机 创建 1次 第一次请求之后 初始化 1次 实例化之后 执行服务 多次 每次请求 销毁 1次 停止服务、 7、注意事项 在Servlet中一般不要轻易使用成员变量，可能会造成线程安全问题 如果要使用，应尽量避免对成员变量产生修改 如果要产生修改，应注意线程安全问题 8、ServletContext对象和ServletConfig对象​ ServletContext叫做Servlet上下文，服务器会为每一个web应用创建一个ServletContext对象，这个对象全局唯一，而且web应用中的所有Servlet都共享这个对象 8.1、ServletContext对象的作用 相对路径转为绝对路径 获取容器的附加信息 读取配置 全局容器 8.2、ServletContext的生命周期​ 当容器启动时会创建ServletContext对象并一直缓存该对象，直到容器关闭后该对象生命周期结束，ServletContext的生命周期非常长，所以在使用全局容器时不建议存放业务数据 8.3、ServletConfig对象​ ServletConfig对象对应web.xml文件中的节点，当Tomcat初始化一个Servlet时，会将该Servlet的配置信息，封装到一个ServletConfig对象中，可以通过该对象读取节点中的配置信息 9、请求转发9.1 forward转发9.1.1 forward转发处理流程 清空response存放的正在响应正文数据缓冲区 如果目标资源为Servlet或jsp，就调用他们的service方法，把该方法产生的响应结果发送到客户端；如果目标资源是静态文件中的HTML，就读取文件中的数据把它发送到客户端 9.1.2 forward处理特点 由于forward()方法先清空用于存放相应正文的缓冲区，因此源Servlet生成的响应结果不会被发送到客户端，只有目标资源生成的响应结果才会被发送到客户端 如果源Servlet在进行请求转发之前，已经提交了响应结(flushBuffer()，close()方法)，那么forward()方法会抛出异常，为避免异常，不应该在源servlet中提交响应结果 9.2 include转发9.2.1 include处理流程 如果目标资源为Servlet或者jsp，就调用他们的service方法，把该方法产生的响应正文添加到源Servlet的响应结果中；如果目标组建为HTML文档，就直接把文档的内容添加到源Servlet的响应结果中 返回到源Servlet的服务方法中，继续执行后续代码 9.2.2 include处理特点 源Servlet与被包含的目标资源的输出数据都会被添加到响应结果中 在目标资源对响应状态码或者响应开头所做的修改都会被忽略 10、Cookie对象和HttpSession对象​ Cookie对象和HttpSession对象的作用是维护客户端浏览器与服务端的会话状态的两个对象，二者的不同是Cookie是通过客户端浏览器实现会话的维持，而HttpSession是通过服务端来实现会话的维持 10.1 区别 cookie数据存放在客户的浏览器或系统文件中，httpsession中的数据存放在服务器中 cookie不安全，httpSession是安全的 单个cookie保存的数据不能超过4K，httpSession无限制","tags":[{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/note/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"servlet","slug":"servlet","permalink":"https://lyblog2022.github.io/note/tags/servlet/"}]},{"title":"MyBatis","date":"2022-06-04T08:59:00.000Z","path":"2022/06/04/study/MyBatis/","text":"MyBatis学习 1、简介Mybatis 是一款优秀的持久层框架，支持定制化SQL、存储过程及高级映射，可以使用简单的XML或注解来配置和映射原生信息 是一款半自动的持久层的半自动ORM映射框架 1.1 框架 框架是一个基本概念上的结构，用于解决或处理复杂的问题。 使用框架的优点：减少开发时间，降低开发难度，保证设计质量，降低程序员之间的沟通以及日后维护的成本 框架是一个半成品，已经对基础的代码进行了封装并提供响应的API，开发者再使用框架是直接调用封装好的API，可以省去很多代码编写，从而提升效率和开发速度 1.2 ORM Object-Relation Mapping，对象关系映射 它的作用是在关系型数据库和对象之间做一个映射，这样在操作具体数据的时候就像操作对象一样 1.2.1 持久化 持久：把数据保存到可永久保存的存储设备中 主要应用：将内存中的数据存储在关系型数据库中 1.2.2 持久层 专注于实现数据持久化应用领域的某一个特定系统的一个逻辑层面，将数据使用者和数据实体想关联（mapper层、DAO层） 2、Mybatis配置2.1 事务​ 在MyBatis 核心配置文件中envirment 中通过transactionManager配置事务的处理策略 JDBC：该配置使用了JDBC的提交及回滚，依赖于从数据源得到的链接来管理事务范围 MANAGED：该配置几乎无任何操作，不提交或回滚一个链接，它会让容器来管理整个生命周期（Spring应用服务器的上下文），默认情况下会关闭链接，但一些容器不希望如此，因此如果需要从链接中停止它，将closeConnection的属性值设置为false，Mybatis本身并不会处理事务，而是交给其他框架去处理 2.2 映射文件的加载方式 mapper的映射文件的文件路径导入，使用的是mapper标签的resource属性 网络资源路径使用的是mapper的url属性 接口的全限定名导入使用的是mapper标签的class属性—–基于接口的代理模式 包扫描形式加载所有的mapper映射文件，使用的package标签 3、Mybatis 开发3.1 传递参数 ${} 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置 #{} 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理，更常用 4、MyBatis代理模式开发在MyBatis中提供了一种称为Mapper代理（接口绑定）的操作方式，在实际开发中也使用该方式 4.1 原理浅析​ 底层使用了动态代理模式，动态创建一个Mapper的一个代理对象并赋给接口使用 5、动态SQL​ MyBatis在简化操作方法上提出了动态SQL功能，将使用Java代码拼接SQL语句，改变为在XML映射文件中截止标签拼接SQL语句。相比而言，大大减少代码量，更灵活、有利于后期维护 ​ MyBatis中动态SQL是编写在mapper.xml中的，其语法和JSTL类似，但是却是基于强大的OGNL表达式实现的 ​ MyBatis也可以在注解中配置SQL，但是由于注解功能受限，尤其是对于复杂的SQL语句，可读性很差，所以较少使用 5.1 If标签条件查询，符合if的条件，则补充SQL语句 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mapper.StudentMapper&quot;&gt; &lt;select id=&quot;findByCondition&quot; resultType=&quot;Student&quot;&gt; select * from student where 1=1 &lt;if test=&quot;stuno != null&quot;&gt; and stuno =#&#123;stuno&#125; &lt;/if&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; and classname like concat(&#x27;%&#x27;,#&#123;classname&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; 5.2 Where标签用于处理where关键字和and 1234567891011&lt;select id=&quot;findStuByCondition&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;where&gt; &lt;if test=&quot;stuno != null&quot;&gt; and stuno= #&#123;stuno&#125; &lt;/if&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; and classname= #&#123;classname&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 5.3 Choose标签前面的when条件成立 后面的 when就不再判断了 12345678910111213&lt;select id=&quot;findStuByCondition&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;stuno != null&quot;&gt; and stuno= #&#123;stuno&#125; &lt;/when&gt; &lt;when test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; and classname= #&#123;classname&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 5.4 Set标签12345678910111213&lt;update id=&quot;updateStuByCondtion&quot; &gt; update student &lt;set&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27; &quot;&gt; , classname =#&#123;classname&#125; &lt;/if&gt; &lt;if test=&quot;stuno != null &quot;&gt; , stuname =#&#123;stuname&#125; &lt;/if&gt; &lt;/set&gt; where stuno =#&#123;stuno&#125;&lt;/update&gt; 5.5 Trim标签123456789101112131415161718&lt;update id=&quot;updateStuByCondition&quot; &gt; update student &lt;!--prefix 要增加什么前缀 prefixOverrides 要去除什么前缀 suffix 要增加什么后缀 suffixOverrides 要去除什么后缀 set 是trim的一种特殊情况 --&gt; &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot; &gt; &lt;if test=&quot;stuname != null and stuname != &#x27;&#x27;&quot;&gt; stuname= #&#123;stuname&#125;, &lt;/if&gt; &lt;if test=&quot;classname != null and classname != &#x27;&#x27;&quot;&gt; classname= #&#123;classname&#125;, &lt;/if&gt; &lt;/trim&gt; where stuno = #&#123;stuno&#125;&lt;/update&gt; 5.6 Bind标签一般用于处理模糊查询的模板 1234&lt;select id=&quot;findStuByClassName&quot; resultType=&quot;Student&quot;&gt; &lt;bind name=&quot;likePattern&quot; value=&quot;&#x27;%&#x27;+param1+&#x27;%&#x27;&quot;&gt;&lt;/bind&gt; select * from student where classname like #&#123;classname&#125;&lt;/select&gt; 6、缓存6.1 一级缓存​ 一级存储是SqlSession上的缓存，默认开启，是一种内存型缓存,不要求实体类对象实现Serializable接口 ​ 缓存中的数据使用键值对形式存储数据 ​ namespace+sqlid+args+offset&gt;&gt;&gt; hash值作为键,查询出的结果作为值 6.2 二级缓存​ 二级缓存是以namespace为标记的缓存，可以是由一个SqlSessionFactory创建的SqlSession之间共享缓存数据。默认并不开启，要求实体类必须实现序列化接口 注意： ​ 1、 MyBatis的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对JavaBean对象实现序列化接口。 ​ 2、二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响 ​ 3、加入Cache元素后，会对相应命名空间所有的select元素查询结果进行缓存，而其中的insert、update、delete在操作是会清空整个namespace的缓存 ​ 4、cache 有一些可选的属性 type, eviction, flushInterval, size, readOnly, blocking。 1&lt;cache type=&quot;&quot; readOnly=&quot;&quot; eviction=&quot;&quot;flushInterval=&quot;&quot;size=&quot;&quot;blocking=&quot;&quot;/&gt; 属性 含义 默认值 type 自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口 null readOnly 是否只读 true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。false:会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全 false eviction 缓存策略LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。FIFO – 先进先出：按对象进入缓存的顺序来移除它们。SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 LRU flushInterval 刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，只有执行update、insert、delete语句才会刷新 null size 缓存对象个数 1024 blocking 是否使用阻塞性缓存BlockingCachetrue：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，否则会在查询数据库以后再释放锁，保证只有一个线程到数据库中查找指定key对应的数据false：不使用阻塞性缓存，性能更好 false ​ 5、如果在加入Cache元素的前提下让个别select 元素不使用缓存，可以使用useCache属性，设置为false。**useCache**控制当前sql语句是否启用缓存 flushCache控制当前sql执行一次后是否刷新缓存 1&lt;select id=&quot;findStuByCondition&quot; resultType=&quot;Student&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt; 6.3 三方缓存+ 分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.`ehcache`,`redis `,`memcache`缓存框架。 + `Ehcache`：是一种广泛使用的开源`java`分布式缓存。主要面向通用缓存，`javaEE `和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式`web application`的","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://lyblog2022.github.io/note/tags/MyBatis/"},{"name":"学习","slug":"学习","permalink":"https://lyblog2022.github.io/note/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"518总结--post请求调用接口","date":"2022-05-18T13:06:35.000Z","path":"2022/05/18/dailysummary/20220518/dailysummary/","text":"使用post方式调用接口并传递参数 方式一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.summary;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import com.alibaba.fastjson.JSONObject;public class Summary &#123; /** * 发送post请求 * @param url：请求URL * @param headerParamsJson：请求header参数 * @param paramJson：请求参数 * @return */ public JSONObject sendData(String url, JSONObject headerParamsJson, JSONObject paramJson) &#123; JSONObject resultJson = new JSONObject(); // 发送post请求 try &#123; HttpPost httppost = new HttpPost(url); RequestConfig defaultRequestConfig = RequestConfig.custom().setConnectTimeout(5000) .setConnectionRequestTimeout(5000).setSocketTimeout(15000).build(); httppost.setConfig(defaultRequestConfig); StringEntity entity = new StringEntity(paramJson.toJSONString(), &quot;utf-8&quot;);// 解决中文乱码问题 entity.setContentEncoding(&quot;UTF-8&quot;); entity.setContentType(&quot;text/json&quot;); httppost.setEntity(entity); httppost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); // 添加header参数 Iterator headerParamsIterator = headerParamsJson.entrySet().iterator(); while (headerParamsIterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) headerParamsIterator.next(); httppost.setHeader(entry.getKey().toString(), entry.getValue().toString()); &#125; // 装填参数 List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); if (paramJson != null) &#123; Iterator iterator = paramJson.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); nvps.add(new BasicNameValuePair((String) entry.getKey(), (String) entry.getValue())); &#125; &#125; UrlEncodedFormEntity reqEntity = new UrlEncodedFormEntity(nvps, &quot;utf-8&quot;); httppost.setEntity(reqEntity); // 执行post请求. CloseableHttpClient httpclient = HttpClients.createDefault(); CloseableHttpResponse response1 = httpclient.execute(httppost); String resultText = &quot;&quot;; try &#123; int statusCode = response1.getStatusLine().getStatusCode(); if (statusCode != 200) &#123; throw new RuntimeException(&quot;请求失败&quot;); &#125; else &#123; // 响应实体 HttpEntity entity2 = response1.getEntity(); if (entity2 != null) &#123; // 响应内容 resultText = EntityUtils.toString(entity2, Charset.forName(&quot;UTF-8&quot;)); resultJson = JSONObject.parseObject(resultText); &#125; &#125; resultJson.put(&quot;code&quot;, statusCode); &#125; finally &#123; response1.close(); &#125; &#125; catch (Exception e) &#123; resultJson.put(&quot;code&quot;, &quot;410&quot;); resultJson.put(&quot;err&quot;, e.toString()); &#125; return resultJson; &#125;&#125;","tags":[{"name":"接口调用","slug":"接口调用","permalink":"https://lyblog2022.github.io/note/tags/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"}]}]