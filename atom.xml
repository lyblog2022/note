<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Note</title>
  
  <subtitle>Welcome To My World</subtitle>
  <link href="https://lyblog2022.github.io/atom.xml" rel="self"/>
  
  <link href="https://lyblog2022.github.io/"/>
  <updated>2022-06-07T05:52:26.528Z</updated>
  <id>https://lyblog2022.github.io/</id>
  
  <author>
    <name>ly</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CentOS 8 安装zookeeper</title>
    <link href="https://lyblog2022.github.io/2022/06/06/software/zookeeper/"/>
    <id>https://lyblog2022.github.io/2022/06/06/software/zookeeper/</id>
    <published>2022-06-06T13:43:24.000Z</published>
    <updated>2022-06-07T05:52:26.528Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS8安装zookeeper</p><span id="more"></span><h3 id="1、检验java环境"><a href="#1、检验java环境" class="headerlink" title="1、检验java环境"></a>1、检验java环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><img src="/2022/06/06/software/zookeeper/jdk.png" class="" title="jdk image"><h3 id="2、安装wget-供文件下载时使用"><a href="#2、安装wget-供文件下载时使用" class="headerlink" title="2、安装wget,供文件下载时使用:"></a>2、安装wget,供文件下载时使用:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><img src="/2022/06/06/software/zookeeper/zookeeper.png" class="" title="zookeeper image"><h3 id="3、下载zookeeper"><a href="#3、下载zookeeper" class="headerlink" title="3、下载zookeeper"></a>3、下载zookeeper</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://downloads.apache.org/zookeeper/zookeeper-3.8.0/apache-zookeeper-3.8.0-bin.tar.gz</span><br></pre></td></tr></table></figure><img src="/2022/06/06/software/zookeeper/zookeeper2.png" class="" title="zookeeper2 image"><h3 id="4、解压，安装"><a href="#4、解压，安装" class="headerlink" title="4、解压，安装"></a>4、解压，安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr</span><br><span class="line">mkdir zookeeper</span><br><span class="line">cd ./zookeeper</span><br><span class="line">tar -zxvf apache-zookeeper-3.8.0-bin.tar.gz</span><br><span class="line">mv apache-zookeeper-3.8.0-bin/ /usr/local/soft/</span><br></pre></td></tr></table></figure><p><em>这块我出现点问题，直接在跟目录下下载的，最好新建一个文件夹</em></p><h3 id="5、创建数据和日志目录"><a href="#5、创建数据和日志目录" class="headerlink" title="5、创建数据和日志目录"></a>5、创建数据和日志目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/zookeeper</span><br><span class="line">mkdir -p /data/zookeeper/data</span><br><span class="line">mkdir -p /data/zookeeper/datalogs</span><br><span class="line">mkdir -p /data/zookeeper/logs</span><br></pre></td></tr></table></figure><p>​说明：</p><pre><code>    + data:数据目录    + datalogs:事务日志    +  logs:zk应用的日志</code></pre><h3 id="6、生成配置文件"><a href="#6、生成配置文件" class="headerlink" title="6、生成配置文件"></a>6、生成配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/soft/apache-zookeeper-3.8.0-bin/conf/</span><br><span class="line">cp zoo_sample.cfg zoo.cfg </span><br></pre></td></tr></table></figure><h3 id="7、设置配置文件"><a href="#7、设置配置文件" class="headerlink" title="7、设置配置文件"></a>7、设置配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi zoo.cfg</span><br></pre></td></tr></table></figure><p>添加内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/data/zookeeper/data</span><br><span class="line">dataLogDir=/data/zookeeper/datalogs</span><br><span class="line">admin.enableServer=false</span><br></pre></td></tr></table></figure><p>​说明：</p><pre><code>    + admin.enableServer=false 用来关闭zk内置的web管理器    + dataDir 定义了zk的数据目录    + dataLogDir 定义了zk的事务日志</code></pre><h3 id="8、配置环境变量"><a href="#8、配置环境变量" class="headerlink" title="8、配置环境变量"></a>8、配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>在末尾增加以下内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ZK_HOME=/usr/local/soft/apache-zookeeper-3.8.0-bin</span><br><span class="line">export PATH=$ZK_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>使环境变量生效:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="9、测试启动停止zookeeper"><a href="#9、测试启动停止zookeeper" class="headerlink" title="9、测试启动停止zookeeper"></a>9、测试启动停止zookeeper</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br><span class="line">zkServer.sh stop</span><br></pre></td></tr></table></figure><img src="/2022/06/06/software/zookeeper/zookeeper3.png" class="" title="zookeeper3 image"><img src="/2022/06/06/software/zookeeper/zookeeper4.png" class="" title="zookeeper4 image">]]></content>
    
    
    <summary type="html">&lt;p&gt;CentOS8安装zookeeper&lt;/p&gt;</summary>
    
    
    
    <category term="CentOs 8" scheme="https://lyblog2022.github.io/categories/CentOs-8/"/>
    
    <category term="software" scheme="https://lyblog2022.github.io/categories/CentOs-8/software/"/>
    
    <category term="zookeeper" scheme="https://lyblog2022.github.io/categories/CentOs-8/software/zookeeper/"/>
    
    
    <category term="software" scheme="https://lyblog2022.github.io/tags/software/"/>
    
    <category term="CentOS 8" scheme="https://lyblog2022.github.io/tags/CentOS-8/"/>
    
    <category term="zookeeper" scheme="https://lyblog2022.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 8 配置JDK环境</title>
    <link href="https://lyblog2022.github.io/2022/06/06/software/jdk/"/>
    <id>https://lyblog2022.github.io/2022/06/06/software/jdk/</id>
    <published>2022-06-06T13:41:00.000Z</published>
    <updated>2022-06-06T14:33:56.749Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 8 安装 JDK环境</p><span id="more"></span><h3 id="1、使用Yum安装"><a href="#1、使用Yum安装" class="headerlink" title="1、使用Yum安装"></a>1、使用Yum安装</h3><p>安装OpenJDK的可以选择此方法，方便快捷</p><h4 id="1-1-查看是否有JDK环境"><a href="#1-1-查看是否有JDK环境" class="headerlink" title="1.1 查看是否有JDK环境"></a>1.1 查看是否有JDK环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><img src="/2022/06/06/software/jdk/jdk1.png" class="" title="jdk1 image"><p>可以看到系统自带的 OpenJDK 版本信息，如果不满足，则卸载现有JDK</p><h4 id="1-2-卸载现有JDK"><a href="#1-2-卸载现有JDK" class="headerlink" title="1.2 卸载现有JDK"></a>1.2 卸载现有JDK</h4><p>使用 rpm 命令查询 java</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure><img src="/2022/06/06/software/jdk/jdk2.png" class="" title="jdk2 image"><p>.noarch文件可以不用管，卸载其余条目</p><p>执行一下命令卸载信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps java-1.8.0-openjdk-1.8.0.201.b09-2.el8.x86_64</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.201.b09-2.el8.x86_64</span><br></pre></td></tr></table></figure><p>卸载完后查询版本信息</p><img src="/2022/06/06/software/jdk/jdk3.png" class="" title="jdk3 image"><h4 id="1-3-使用Yum安装OpenJDK"><a href="#1-3-使用Yum安装OpenJDK" class="headerlink" title="1.3 使用Yum安装OpenJDK"></a>1.3 使用Yum安装OpenJDK</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk</span><br></pre></td></tr></table></figure><h5 id="1-3-1-报错"><a href="#1-3-1-报错" class="headerlink" title="1.3.1 报错"></a>1.3.1 报错</h5><img src="/2022/06/06/software/jdk/jdk4.png" class="" title="jdk4 image"><p>报错信息为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Failed to synchronize cache for repo &#x27;AppStream&#x27;, ignoring this repo.</span><br><span class="line">Failed to synchronize cache for repo &#x27;BaseOS&#x27;, ignoring this repo.</span><br></pre></td></tr></table></figure><h5 id="1-3-2-解决方案"><a href="#1-3-2-解决方案" class="headerlink" title="1.3.2 解决方案"></a>1.3.2 <strong>解决方案</strong></h5><p><a href="https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11CuEoi9">切换阿里源</a></p><p>1、备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><p>2、下载新的 CentOS-Base.repo 到 &#x2F;etc&#x2F;yum.repos.d&#x2F;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo</span><br></pre></td></tr></table></figure><p>3、生成缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><img src="/2022/06/06/software/jdk/jdk5.png" class="" title="jdk5 image"><h4 id="1-4-校验"><a href="#1-4-校验" class="headerlink" title="1.4 校验"></a>1.4 校验</h4><img src="/2022/06/06/software/jdk/jdk6.png" class="" title="jdk6 image"><h3 id="2、使用rpm包安装"><a href="#2、使用rpm包安装" class="headerlink" title="2、使用rpm包安装"></a>2、使用rpm包安装</h3><p>适用于有提供RPM Package的情况，例如Oracle JDK有提供。</p><p><a href="https://www.oracle.com/java/technologies/downloads/archive/">Oracle JDK所有版本下载</a></p><p><a href="https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html">OracleJDK8下载</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CentOS 8 安装 JDK环境&lt;/p&gt;</summary>
    
    
    
    <category term="CentOs 8" scheme="https://lyblog2022.github.io/categories/CentOs-8/"/>
    
    <category term="software" scheme="https://lyblog2022.github.io/categories/CentOs-8/software/"/>
    
    <category term="jdk" scheme="https://lyblog2022.github.io/categories/CentOs-8/software/jdk/"/>
    
    
    <category term="software" scheme="https://lyblog2022.github.io/tags/software/"/>
    
    <category term="jdk" scheme="https://lyblog2022.github.io/tags/jdk/"/>
    
    <category term="CentOS 8" scheme="https://lyblog2022.github.io/tags/CentOS-8/"/>
    
  </entry>
  
  <entry>
    <title>RPC-远程服务调用</title>
    <link href="https://lyblog2022.github.io/2022/06/05/study/RPC/"/>
    <id>https://lyblog2022.github.io/2022/06/05/study/RPC/</id>
    <published>2022-06-05T08:45:21.000Z</published>
    <updated>2022-06-06T04:59:46.603Z</updated>
    
    <content type="html"><![CDATA[<p>RPC–远程服务调用</p><span id="more"></span><h2 id="1、RPC"><a href="#1、RPC" class="headerlink" title="1、RPC"></a>1、RPC</h2><h3 id="1-1-RFC"><a href="#1-1-RFC" class="headerlink" title="1.1 RFC"></a>1.1 RFC</h3><p>​RFC(Request For Comments) 是由互联网工程任务组(IETF)发布的文件集。文件集中每个文件都有自己唯一编号，例如：rfc1831。目前RFC文件由互联网协会(Internet Society，ISOC)赞助发型。</p><p>​RPC就收集到了rfc 1831中。可以通过下面网址查看：</p><p>​<a href="https://datatracker.ietf.org/doc/rfc1831/">https://datatracker.ietf.org/doc/rfc1831/</a></p><h3 id="1-2-RPC"><a href="#1-2-RPC" class="headerlink" title="1.2 RPC"></a>1.2 RPC</h3><p>​<code>RPC</code>在<code>rfc 1831</code>中收录 ，<code>RPC</code>（<code>Remote Procedure Call</code>） 远程过程调用协议</p><p>​RPC协议规定允许互联网中一台主机程序调用另一台主机程序，而程序员无需对这个交互过程进行编程。在<code>RPC</code>协议中强调当A程序调用B程序中功能或方法时，A是不知道B中方法具体实现的。</p><p>​<code>RPC</code>是上层协议，底层可以基于<code>TCP</code>协议，也可以基于HTTP协议。一般我们说RPC都是基于RPC的<code>具体</code>实现，如：<code>Dubbo</code>框架。从广义上讲只要是满足网络中进行通讯调用都统称为<code>RPC</code>，甚至<code>HTTP</code>协议都可以说是<code>RPC</code>的具体实现，但是具体分析看来<code>RPC</code>协议要比<code>HTTP</code>协议更加高效，基于<code>RPC</code>的框架功能更多。</p><p>​<code>RPC</code>协议是基于分布式架构而出现的，所以<code>RPC</code>在分布式项目中有着得天独厚的优势。</p><h3 id="1-3-RPC和HTTP"><a href="#1-3-RPC和HTTP" class="headerlink" title="1.3 RPC和HTTP"></a>1.3 RPC和HTTP</h3><h4 id="1-3-1-具体实现"><a href="#1-3-1-具体实现" class="headerlink" title="1.3.1 具体实现"></a>1.3.1 具体实现</h4><p>​<code>RPC</code>：可以基于<code>TCP</code>协议，也可以基于<code>HTTP</code>协议。</p><p>​<code>HTTP</code>：基于<code>HTTP</code>协议</p><h4 id="1-3-2-效率"><a href="#1-3-2-效率" class="headerlink" title="1.3.2 效率"></a>1.3.2 效率</h4><p>​<code>RPC</code>：自定义具体实现可以减少很多无用的报文内容，使得报文体积更小。</p><p>​<code>HTTP</code>：如果是<code>HTTP 1.1</code> 报文中很多内容都是无用的。如果是<code>HTTP2.0</code>以后和<code>RPC</code>相差不大，比<code>RPC</code>少的可能就是一些服务治理等功能。</p><h4 id="1-3-3-链接方式"><a href="#1-3-3-链接方式" class="headerlink" title="1.3.3 链接方式"></a>1.3.3 链接方式</h4><p>​<code>RPC</code>：长连接支持。</p><p>​<code>HTTP</code>：每次连接都是3次握手。</p><h4 id="1-3-4-性能"><a href="#1-3-4-性能" class="headerlink" title="1.3.4 性能"></a>1.3.4 性能</h4><p>​<code>RPC</code>：可以基于很多序列化方式。如：<code>thrift</code></p><p>​<code>HTTP</code>：主要是通过<code>JSON</code>，序列化和反序列效率更低。</p><h4 id="1-3-5-注册中心"><a href="#1-3-5-注册中心" class="headerlink" title="1.3.5 注册中心"></a>1.3.5 注册中心</h4><p>​<code>RPC </code>：一般RPC框架都带有注册中心。</p><p>​<code>HTTP</code>：都是直连。</p><h4 id="1-3-6-负载均衡"><a href="#1-3-6-负载均衡" class="headerlink" title="1.3.6 负载均衡"></a>1.3.6 负载均衡</h4><p>​<code>RPC</code>：绝大多数RPC框架都带有负载均衡测量。</p><p>​<code>HTTP</code>：一般都需要借助第三方工具。如：<code>nginx</code></p><h4 id="1-3-7-综合结论"><a href="#1-3-7-综合结论" class="headerlink" title="1.3.7 综合结论"></a>1.3.7 综合结论</h4><p>​<code>RPC</code>框架：一般都带有丰富的服务治理等功能，更适合企业内部接口调用。</p><p>​<code>HTTP</code>：更适合多平台之间相互调用。</p><h2 id="2、HttpClient实现RPC"><a href="#2、HttpClient实现RPC" class="headerlink" title="2、HttpClient实现RPC"></a>2、HttpClient实现RPC</h2><h3 id="2-1-HttpClient简介"><a href="#2-1-HttpClient简介" class="headerlink" title="2.1 HttpClient简介"></a>2.1 HttpClient简介</h3><p>​在<code>JDK</code>中<code>java.net</code>包下提供了用户<code>HTTP</code>访问的基本功能，但是它缺少灵活性或许多应用所需要的功能。</p><p>​<code>HttpClient</code>起初是<code>Apache Jakarta Common</code> 的子项目。用来提供高效的、最新的、功能丰富的支持 <code>HTTP </code>协议的客户端编程工具包，并且它支持 <code>HTTP </code>协议最新的版本。2007年成为顶级项目。</p><p>​通俗解释：<code>HttpClient</code>可以实现使用<code>Java</code>代码完成标准<code>HTTP</code>请求及响应。</p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><h4 id="2-2-1-服务端"><a href="#2-2-1-服务端" class="headerlink" title="2.2.1 服务端"></a>2.2.1 服务端</h4><p>1、新建控制器</p><p>com.controller.DemoController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/demo&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">(String param)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo&quot;</span>+param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、启动器</p><p>com.HttpClientServerApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(HttpClientServerApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-客户端"><a href="#2-2-2-客户端" class="headerlink" title="2.2.2 客户端"></a>2.2.2 客户端</h4><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、新建类</p><p>新建com.HttpClientDemo，编写主方法。</p><p>​1、使用Get方法访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建http工具（理解成:浏览器） 发起请求，解析响应</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="comment">//请求路径</span></span><br><span class="line">        <span class="type">URIBuilder</span> <span class="variable">uriBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URIBuilder</span>(<span class="string">&quot;http://localhost:8080/demo&quot;</span>);</span><br><span class="line">        uriBuilder.addParameter(<span class="string">&quot;param&quot;</span>, <span class="string">&quot;get123&quot;</span>);</span><br><span class="line">        <span class="comment">//创建HttpGet请求对象</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(uriBuilder.build());</span><br><span class="line">        <span class="comment">//创建响应对象</span></span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(get);</span><br><span class="line">        <span class="comment">//由于响应体是字符串，因此把HttpEntity类型转换为字符串类型，并设置字符编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        response.close();</span><br><span class="line">        httpClient.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​2、使用Post方式访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建http工具（理解成:浏览器） 发起请求，解析响应</span></span><br><span class="line">            <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">            <span class="comment">//创建HttpPOST请求对象</span></span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://localhost:8080/demo&quot;</span>);</span><br><span class="line">            <span class="comment">//所有请求参数</span></span><br><span class="line">            List&lt;NameValuePair&gt; params = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            params.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;param&quot;</span>,<span class="string">&quot;123&quot;</span>));</span><br><span class="line">            <span class="comment">//创建HttpEntity接口的文本实现类的对象，放入参数并设置编码</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">httpEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlEncodedFormEntity</span>(params,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//放入到HttpPost对象中</span></span><br><span class="line">            post.setEntity(httpEntity);            </span><br><span class="line">            <span class="comment">//创建响应对象</span></span><br><span class="line">            <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(post);</span><br><span class="line">            <span class="comment">//由于响应体是字符串，因此把HttpEntity类型转换为字符串类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">            <span class="comment">//输出结果</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            response.close();</span><br><span class="line">            httpClient.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Jackson用法"><a href="#2-3-Jackson用法" class="headerlink" title="2.3 Jackson用法"></a>2.3 Jackson用法</h3><h4 id="2-3-1-对象-–-gt-json字符串"><a href="#2-3-1-对象-–-gt-json字符串" class="headerlink" title="2.3.1 对象 –&gt; json字符串"></a>2.3.1 对象 –&gt; json字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">People</span> <span class="variable">peo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">objectMapper.writeValueAsString(peo);</span><br></pre></td></tr></table></figure><h4 id="2-3-2-json-–-gt-对象"><a href="#2-3-2-json-–-gt-对象" class="headerlink" title="2.3.2 json –&gt; 对象"></a>2.3.2 json –&gt; 对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">People</span> <span class="variable">peo</span> <span class="operator">=</span> objectMapper.readValue(content, People.class);</span><br></pre></td></tr></table></figure><h4 id="2-3-3-json-–-gt-List集合"><a href="#2-3-3-json-–-gt-List集合" class="headerlink" title="2.3.3 json –&gt; List集合"></a>2.3.3 json –&gt; List集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">JavaType</span> <span class="variable">javaType</span> <span class="operator">=</span> objectMapper.getTypeFactory().constructParametricType(List.class, People.class);</span><br><span class="line">List&lt;People&gt; list = objectMapper.readValue(content, javaType);</span><br></pre></td></tr></table></figure><h3 id="2-4-HttpClient请求包含JSON"><a href="#2-4-HttpClient请求包含JSON" class="headerlink" title="2.4 HttpClient请求包含JSON"></a>2.4 HttpClient请求包含JSON</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://localhost:8080/demo&quot;</span>);</span><br><span class="line">            HttpEntity httpEntity= <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line">            <span class="type">StringEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(json, ContentType.APPLICATION_JSON);</span><br><span class="line">            post.setEntity(entity);</span><br><span class="line">            <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(post);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            response.close();</span><br><span class="line">            httpClient.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-控制器接口参数"><a href="#2-5-控制器接口参数" class="headerlink" title="2.5 控制器接口参数"></a>2.5 控制器接口参数</h3><p>@RequestBody把请求体中流数据转换为指定的对象。多用在请求参数是json数据且请求的Content-Type&#x3D;”application&#x2F;json”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/demo4&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">demo4</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;People&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="keyword">return</span> list.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-Ajax发送json参数写法"><a href="#2-6-Ajax发送json参数写法" class="headerlink" title="2.6 Ajax发送json参数写法"></a>2.6 Ajax发送json参数写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var json = &#x27;[&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;ly&quot;&#125;,&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;ly123&quot;&#125;]&#x27;;</span><br><span class="line"> $.ajax(&#123;</span><br><span class="line">     url:&#x27;/demo5&#x27;,</span><br><span class="line">     type:&#x27;post&#x27;,</span><br><span class="line">     success:function(data)&#123;</span><br><span class="line">         alert(data);</span><br><span class="line">         for(var i = 0 ;i&lt;data.length;i++)&#123;</span><br><span class="line">alert(data[i].id +&quot;  &quot;+data[i].name);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     contentType:&#x27;application/json&#x27;,//请求体中内容类型</span><br><span class="line">     dataType:&#x27;json&#x27;,//响应内容类型。</span><br><span class="line">     data:json</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h3 id="2-7-跨域"><a href="#2-7-跨域" class="headerlink" title="2.7 跨域"></a>2.7 跨域</h3><p>跨域：协议、IP、端口中只要有一个不同的就是跨域请求</p><p>同源策略：浏览器默认只允许ajax访问同源（协议、IP、端口）内容</p><p>解决同源策略：在控制器接口上添加@CrossOrigin。表示允许跨域。本质在响应头中添加Access-Control-Allow-Origin: *</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var json = &#x27;[&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;ly&quot;&#125;,&#123;&quot;id&quot;:456,&quot;name&quot;:&quot;ly1234&quot;&#125;]&#x27;;</span><br><span class="line"> $.ajax(&#123;</span><br><span class="line">     url:&#x27;/demo5&#x27;,</span><br><span class="line">     type:&#x27;post&#x27;,</span><br><span class="line">     success:function(data)&#123;</span><br><span class="line">         alert(data);</span><br><span class="line">         for(var i = 0 ;i&lt;data.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">             alert(data[i].id +&quot;  &quot;+data[i].name);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     contentType:&#x27;application/json&#x27;,//请求体中内容类型</span><br><span class="line">     dataType:&#x27;json&#x27;,//响应内容类型。</span><br><span class="line">     data:json</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="3、RMI实现RPC"><a href="#3、RMI实现RPC" class="headerlink" title="3、RMI实现RPC"></a>3、RMI实现RPC</h2><h3 id="3-1-RMI简介"><a href="#3-1-RMI简介" class="headerlink" title="3.1 RMI简介"></a>3.1 RMI简介</h3><ul><li>RMI(Remote Method Invocation) 远程方法调用。</li><li>RMI是从JDK1.2推出的功能，它可以实现在一个Java应用中可以像调用本地方法一样调用另一个服务器中Java应用（JVM）中的内容。</li><li>RMI 是Java语言的远程调用，无法实现跨语言。</li></ul><h3 id="3-2-执行流程"><a href="#3-2-执行流程" class="headerlink" title="3.2 执行流程"></a>3.2 执行流程</h3><img src="/2022/06/05/study/RPC/rpc-01.png" class="" title="rpc-01 image"><p>​Registry(注册表)是放置所有服务器对象的命名空间。 每次服务端创建一个对象时，它都会使用bind()或rebind()方法注册该对象。 这些是使用称为绑定名称的唯一名称注册的。 </p><p>​要调用远程对象，客户端需要该对象的引用。即通过服务端绑定的名称从注册表中获取对象(lookup()方法)。</p><h3 id="3-3-API"><a href="#3-3-API" class="headerlink" title="3.3 API"></a>3.3 API</h3><h4 id="3-3-1-Remote"><a href="#3-3-1-Remote" class="headerlink" title="3.3.1 Remote"></a>3.3.1 Remote</h4><p>java.rmi.Remote 定义了此接口为远程调用接口。如果接口被外部调用，需要继承此接口。</p><h4 id="3-3-2-RemoteException"><a href="#3-3-2-RemoteException" class="headerlink" title="3.3.2 RemoteException"></a>3.3.2 RemoteException</h4><p>​java.rmi.RemoteException</p><p>​继承了Remote接口的接口中，如果方法是允许被远程调用的，需要抛出此异常。</p><h4 id="3-3-3-UnicastRemoteObject"><a href="#3-3-3-UnicastRemoteObject" class="headerlink" title="3.3.3 UnicastRemoteObject"></a>3.3.3 UnicastRemoteObject</h4><p>​java.rmi.server.UnicastRemoteObject</p><p>​此类实现了Remote接口和Serializable接口。</p><p>​自定义接口实现类除了实现自定义接口还需要继承此类。</p><h4 id="3-3-4-LocateRegistry"><a href="#3-3-4-LocateRegistry" class="headerlink" title="3.3.4 LocateRegistry"></a>3.3.4 LocateRegistry</h4><p>​java.rmi.registry.LocateRegistry</p><p>​可以通过LocateRegistry在本机上创建Registry，通过特定的端口就可以访问这个Registry。</p><h4 id="3-3-5-Naming"><a href="#3-3-5-Naming" class="headerlink" title="3.3.5 Naming"></a>3.3.5 Naming</h4><p>​java.rmi.Naming</p><p>​Naming定义了发布内容可访问RMI名称。也是通过Naming获取到指定的远程方法。</p><h3 id="3-4-代码实现"><a href="#3-4-代码实现" class="headerlink" title="3.4 代码实现"></a>3.4 代码实现</h3><h4 id="3-4-1-服务端"><a href="#3-4-1-服务端" class="headerlink" title="3.4.1 服务端"></a>3.4.1 服务端</h4><p>1、编写接口</p><p>com.service.DemoService 编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoService</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">demo</span><span class="params">(String demo)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、编写实现类</p><p>com.service.impl.DemoServiceImpl 编写。</p><p>注意：构造方法是public的。默认生成protected</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">(String demo)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> demo+<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、主方法</p><p>编写com.DemoServer类，生成主方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">(String demo)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> demo+<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行项目</p><p>运行后项目，项目一直处于启动状态，表示可以远程访问此项目中的远程方法。</p><h4 id="3-4-2-创建客户端代码"><a href="#3-4-2-创建客户端代码" class="headerlink" title="3.4.2  创建客户端代码"></a>3.4.2  创建客户端代码</h4><p>1、复制服务端接口</p><p>把服务端com.service.DemoService粘贴到项目中</p><p>2、创建主方法</p><p>新建com.DemoClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">(String demo)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> demo+<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;RPC–远程服务调用&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="RPC" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/RPC/"/>
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="RPC" scheme="https://lyblog2022.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="https://lyblog2022.github.io/2022/06/05/study/SpringBoot/"/>
    <id>https://lyblog2022.github.io/2022/06/05/study/SpringBoot/</id>
    <published>2022-06-05T07:02:13.000Z</published>
    <updated>2022-06-05T08:35:39.155Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot学习1</p><span id="more"></span><h2 id="1、SpringBoot"><a href="#1、SpringBoot" class="headerlink" title="1、SpringBoot "></a>1、<code>SpringBoot </code></h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><ul><li><code>Spring Boot</code>是<code>Spring</code>公司的一个顶级项目，和<code>Spring Framework</code>是一个级别的。</li><li><code>Spring Boot</code>实际上是利用<code>Spring Framework 4</code> 自动配置特性完成。编写项目时不需要编写<code>xml</code>文件。发展到现在，<code>Spring Boot</code>已经具有很很大的生态圈，各种主流技术已经都提供了<code>Spring Boot</code>的启动器。</li></ul><h3 id="1-2-启动器"><a href="#1-2-启动器" class="headerlink" title="1.2 启动器"></a>1.2 启动器</h3><p>​<code>Spring</code>框架在项目中作用是<code>Spring</code>整合各种其他技术，让其他技术使用更加方便。<code>Spring Boot</code>的启动器实际上就是一个依赖。这个依赖中包含了整个这个技术的相关<code>jar</code>包，还包含了这个技术的自动配置，以前绝大多数<code>XML</code>配置都不需要配置了。当然了，启动器中自动配置无法实现所有内容的自动配置，在使用<code>Spring Boot</code>时还需要进行少量的配置（这个配置不是在<code>xml</code>中了，而是在<code>properties</code>或<code>yml</code>中即可）。如果是<code>Spring</code>自己封装的启动器的<code>artifact id</code>名字满足：<code>spring-boot-starter-xxxx</code>，如果是第三方公司提供的启动满足：<code>xxxx-spring-boot-starter</code>。以后每次使用<code>Spring Boot</code>整合其他技术时首先需要考虑导入启动器。 </p><h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a>1.3 优点</h3><ol><li>使用<code>Spring Boot</code>可以创建独立的<code>Spring</code>应用程序</li><li>在<code>Spring Boot</code>中直接嵌入了<code>Tomcat</code>、<code>Jetty</code>、<code>Undertow</code>等<code>Web </code>容器，在使用<code>SpringBoot</code>做<code>Web</code>开发时不需要部署<code>WAR</code>文件</li><li>通过提供自己的启动器(<code>Starter</code>)依赖，简化项目构建配置</li><li>尽量的自动配置<code>Spring</code>和第三方库</li><li>绝对没有代码生成，也不需要<code>XML</code>配置文件</li></ol><h3 id="1-4-核心"><a href="#1-4-核心" class="headerlink" title="1.4 核心"></a>1.4 核心</h3><p>起步依赖- 起步依赖本质上是一个<code>Maven</code>项目对象模型（<code>Project Object Model</code>，<code>POM</code>），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 </p><p>自动配置 -<code>Spring Boot</code>的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 <code>Spring</code>配置应该用哪个，不该用哪个。该过程是<code>Spring</code>自动完成的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SpringBoot学习1&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="springboot" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/springboot/"/>
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="springboot" scheme="https://lyblog2022.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="https://lyblog2022.github.io/2022/06/05/study/SpringMVC/"/>
    <id>https://lyblog2022.github.io/2022/06/05/study/SpringMVC/</id>
    <published>2022-06-05T04:55:50.000Z</published>
    <updated>2022-06-05T06:55:42.435Z</updated>
    
    <content type="html"><![CDATA[<p>Springmvc学习</p><span id="more"></span><h2 id="1、SpringMVC"><a href="#1、SpringMVC" class="headerlink" title="1、SpringMVC"></a>1、SpringMVC</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul><li><code>SpringMVC</code>是<code>spring</code>为展现层提供的基于<code>MVC</code>设计理念的优秀WEB框架，是目前最主流的<code>MVC</code>框架之一</li><li><code>SpringMVC</code>通过一套注解，可以让普通的<code>JAVA</code>类成为<code>contrllor</code>控制器，无需继承<code>Servlet</code>，实现了控制层和<code>Servlet</code>之间的解耦</li><li><code>SpringMVC</code>支持<code>Rest</code>风格的<code>URL</code>写法</li><li><code>SpringMVC</code>采用了松耦合，可热插的主键结构，比其他的框架更具扩展性和灵活性</li></ul><h3 id="1-2-执行流程"><a href="#1-2-执行流程" class="headerlink" title="1.2 执行流程"></a>1.2 执行流程</h3><ol><li><p><code>DispatcherServlet</code>：前端控制器</p><p>用户请求到达前端控制器，它就相当于 <code>mvc</code> 模式中的 <code>c</code>，<code>dispatcherServlet </code>是整个流程控制的中心，由它调用其它组件处理用户的请求，<code>dispatcherServlet </code>的存在降低了组件之间的耦合性。</p></li><li><p><code>HandlerMapping</code>：处理器映射器</p><p><code>HandlerMapping </code>负责根据用户请求找到 <code>Handler </code>即处理器，<code>SpringMVC </code>提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p><code>HandlerMapping</code>的实现类的作用：实现类<code>RequestMappingHandlerMapping</code>，它会处理<code>@RequestMapping</code> 注解，并将其注册到请求映射表中。</p></li><li><p><code>Handler</code>：处理器 (自己定义的<code>Controller</code>处理单元)</p><p>它就是我们开发中要编写的具体业务控制器。由 <code>DispatcherServlet </code>把用户请求转发到 <code>Handler</code>。由 <code>Handler </code>对具体的用户请求进行处理。</p></li><li><p><code>HandlAdapter</code>：处理器适配器</p><p>通过 <code>HandlerAdapter</code> 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行</p><p><code>HandlerAdapter</code>的实现类的作用：实现类<code>RequestMappingHandlerAdapter</code>，则是处理请求的适配器，确定调用哪个类的哪个方法，并且构造方法参数，返回值。</p></li><li><p><code>View Resolver</code>：视图解析器</p><p><code>View Resolver</code> 负责将处理结果生成 <code>View </code>视图，<code>View Resolver</code> 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 <code>View </code>视图对象，最后对 <code>View </code>进行渲染将处理结果通过页面展示给用户。</p></li><li><p><code>View</code>：视图</p><p><code>SpringMVC </code>框架提供了很多的 <code>View </code>视图类型的支持，包括：<code>jstlView</code>、<code>freemarkerView</code>、<code>pdfView</code>等。我们最常用的视图就是 <code>jsp</code>。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开 发具体的页面。</p></li></ol><h2 id="2、-获取请求参数"><a href="#2、-获取请求参数" class="headerlink" title="2、 获取请求参数"></a>2、 获取请求参数</h2><h3 id="2-1-紧耦合方式"><a href="#2-1-紧耦合方式" class="headerlink" title="2.1 紧耦合方式"></a>2.1 紧耦合方式</h3><p>​<code>DispatcherServlet</code>中的<code>service</code>方法直接将此次请求的<code>request</code>对象传递给调用的单元方法即可。同时在单元方法上声明形参<code>HttpServletRequest</code>来接收<code>request</code>实参即可。</p><h3 id="2-2-解耦合方式"><a href="#2-2-解耦合方式" class="headerlink" title="2.2 解耦合方式"></a>2.2 解耦合方式</h3><p>​<code>DispatcherServlet</code>在其<code>service</code>方法中将请求数据根据需求从<code>request</code>对象中获取出来后，将数据直接传递给对应的单元方法使用。同时在单元方法上直接声明对应的形参接收请求数据即可。在单元方法上声明形参来接收请求数据时，形参名必须和请求数据的键名一致，<code>DispatcherServlet</code>会将调用单元方法的形参名作为请求数据的键名获取请求数据，然后传递给单元方法。</p><h3 id="2-3-常见注解"><a href="#2-3-常见注解" class="headerlink" title="2.3 常见注解"></a>2.3 常见注解</h3><h4 id="2-3-1-RequestMapping"><a href="#2-3-1-RequestMapping" class="headerlink" title="2.3.1 @RequestMapping"></a>2.3.1 <strong>@RequestMapping</strong></h4><ul><li>作用：用于建立请求 <code>URL </code>和处理请求方法之间的对应关系</li><li>出现位置：<ul><li>类上：请求 <code>URL </code>的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以&#x2F;开头</li><li>方法上：请求 <code>URL </code>的第二级访问目录</li></ul></li><li>属性：<ul><li><code>value</code>：用于指定请求的 <code>URL</code>。它和 <code>path </code>属性的作用是一样的。</li><li><code>method</code>：用于指定请求的方式。</li></ul></li></ul><h4 id="2-3-2-RequestParam"><a href="#2-3-2-RequestParam" class="headerlink" title="2.3.2 @RequestParam"></a>2.3.2 @RequestParam</h4><ul><li><p>作用：把请求中指定名称的参数给控制器中的形参赋值。</p></li><li><p>属性：</p><ul><li><code>value</code>：请求参数中的名称。</li><li><code>required</code>：请求参数中是否必须提供此参数。默认值：<code>true</code>。表示必须提供，如果不提供将报错。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getRequestParam&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getRequestParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String uname, <span class="meta">@RequestParam(value=&quot;age&quot;, required=false)</span> Integer age)</span> &#123; </span><br><span class="line">System.out.println(username+<span class="string">&quot;,&quot;</span>+age); </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-PathVariable"><a href="#2-3-3-PathVariable" class="headerlink" title="2.3.3 @PathVariable"></a>2.3.3 @PathVariable</h4><ul><li>作用：用于绑定 <code>url </code>中的占位符。例如：请求 <code>url </code>中 &#x2F;<code>delete</code>&#x2F;**{id}<strong>，这个</strong>{id}**就是 <code>url </code>占位符。 <code>url </code>支持占位符是 <code>spring3.0 </code>之后加入的。是 <code>springmvc </code>支持 <code>rest </code>风格 <code>URL </code>的一个重要标志。</li><li>属性：<ul><li><code>value</code>：用于指定 <code>url </code>中占位符名称。</li><li><code>required</code>：是否必须提供占位符。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathController</span> &#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPathVariable</span><span class="params">( <span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;id:&quot;</span>+id);</span><br><span class="line">System.out.println(<span class="string">&quot;username:&quot;</span>+username);</span><br><span class="line">System.out.println(<span class="string">&quot;testPathVariable1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、作用域传参"><a href="#3、作用域传参" class="headerlink" title="3、作用域传参"></a>3、作用域传参</h2><h3 id="3-1-PageContext对象"><a href="#3-1-PageContext对象" class="headerlink" title="3.1 PageContext对象"></a>3.1 PageContext对象</h3><ul><li>作用域范围：当前jsp页面内有效</li></ul><h3 id="3-2-request对象"><a href="#3-2-request对象" class="headerlink" title="3.2 request对象"></a>3.2 request对象</h3><ul><li>作用域范围：一次请求内。</li><li>作用: 解决了一次请求内的资源的数据共享问题</li></ul><h3 id="3-3-session对象"><a href="#3-3-session对象" class="headerlink" title="3.3 session对象"></a>3.3 session对象</h3><ul><li>作用域范围：一次会话内有效。</li><li>说明：浏览器不关闭，并且后台的session不失效，在任意请求中都可以获取到同一个session对象。</li><li>作用：解决了一个用户不同请求的数据共享问题。</li></ul><h3 id="3-4-application-ServletContext-对象"><a href="#3-4-application-ServletContext-对象" class="headerlink" title="3.4 application(ServletContext)对象"></a>3.4 application(ServletContext)对象</h3><ul><li>作用域范围：整个项目内有效。</li><li>特点：一个项目只有一个，在服务器启动的时候即完成初始化创建无论如何获取都是同一个项目。</li><li>作用：解决了不同用户的数据共享问题。</li></ul><h2 id="4、拦截器"><a href="#4、拦截器" class="headerlink" title="4、拦截器"></a>4、拦截器</h2><p><code>Spring MVC</code>中的拦截器（<code>Interceptor</code>）类似于Servlet中的过滤器（<code>Filter</code>），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。</p><p>  要使用<code>Spring MVC</code>中的拦截器，就需要对拦截器类进行定义和配置。通常拦截器类可以通过两种方式来定义。 </p><ol><li><p>通过实现<code>HandlerInterceptor</code>接口，或继承<code>HandlerInterceptor</code>接口的实现类（如<code>HandlerInterceptorAdapter</code>）来定义。 </p></li><li><p>通过实现<code>WebRequestInterceptor</code>接口，或继承<code>WebRequestInterceptor</code>接口的实现类来定义。</p></li></ol><h3 id="4-1-拦截器过滤器区别"><a href="#4-1-拦截器过滤器区别" class="headerlink" title="4.1 拦截器过滤器区别"></a>4.1 拦截器过滤器区别</h3><ol><li>拦截器<code>SpringMVC</code>的，而过滤器是<code>servlet</code>的。</li><li>拦截器不依赖与<code>servlet</code>容器，由<code>spring</code>容器初始化，过滤器依赖与<code>servlet</code>容器，由<code>servlet</code>容器初始化。</li><li>拦截器只能对<code>action</code>请求起作用，而过滤器则可以对几乎所有的请求起作用。</li><li>拦截器可以访问<code>action</code>上下文、值栈里的对象，而过滤器不能访问。</li><li>在<code>action</code>的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li><li>拦截器可以获取<code>IOC</code>容器中的各个<code>bean</code>，而过滤器就不太方便，这点很重要，在拦截器里注入一个<code>service</code>，可以调用业务逻辑。</li></ol><h3 id="4-2-preHandle方法"><a href="#4-2-preHandle方法" class="headerlink" title="4.2 preHandle方法"></a>4.2 preHandle方法</h3><ul><li><p>执行时机：再进入控制单元方法之前执行</p></li><li><p>调用：按拦截器定义顺序调用</p></li><li><p>具体作用：如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去 进行处理，则返回 <code>true</code>。 如果程序员决定不需要再调用其他的组件去处理请求，则返回 <code>false</code>。</p></li><li><p>参数：</p><ul><li><code>HttpServletRequest arg0</code>，拦截的请求的<code>request</code>对象</li><li><code>HttpServletResponse arg1</code>，拦截的请求的<code>response</code>对象</li><li><code>Object arg2</code> 封存了单元方法对象的<code>HandleMethod</code>对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request  请求对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response 响应对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler  目标要调用的Handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回true放行,返回false拦截</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">/*在请求到达我们定义的handler之前工作的*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor preHandle&quot;</span>);</span><br><span class="line"><span class="comment">/*设置请求和响应的乱码 */</span></span><br><span class="line"><span class="comment">/* request.setCharacterEncoding(&quot;UTF-8&quot;);</span></span><br><span class="line"><span class="comment">response.setCharacterEncoding(&quot;UTF-8&quot;);*/</span></span><br><span class="line"><span class="comment">// 判断是否登录</span></span><br><span class="line"><span class="comment">/*User user =(User) request.getSession().getAttribute(&quot;user&quot;);</span></span><br><span class="line"><span class="comment">if(null == user)</span></span><br><span class="line"><span class="comment">response.sendRedirect(&quot;index.jsp&quot;);</span></span><br><span class="line"><span class="comment">return false;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户权限控制</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-postHandle方法"><a href="#4-3-postHandle方法" class="headerlink" title="4.3 postHandle方法"></a>4.3 postHandle方法</h3><ul><li><p>执行时机：在进行数据处理和做出响应之间进行这个方法的调用</p></li><li><p>调用：在拦截器链内所有拦截器返成功调用</p></li><li><p>作用：在业务处理器处理完请求后，但是 <code>DispatcherServlet</code> 向客户端返回响应前被调用，在该方法中对用户请求 <code>request</code>域数据进行处理。</p></li><li><p>参数：</p><ul><li><code>HttpServletRequest arg0</code>，拦截的请求的<code>request</code>对象</li><li><code>HttpServletResponse arg1</code>，拦截的请求的<code>response</code>对象</li><li><code>Object arg2</code>，封存了单元方法对象的<code>HandleMethod</code>对象</li><li><code>ModelAndView arg3</code>，封存了单元方法的返回值资源路径和请求转到的<code>Map</code>数据</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modelAndView  controller响应的结果,视图和数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor postHandle&quot;</span>);</span><br><span class="line"><span class="comment">/*控制数据*/</span></span><br><span class="line"><span class="comment">/*Map&lt;String, Object&gt; map = modelAndView.getModel();</span></span><br><span class="line"><span class="comment">String msg = (String)map.get(&quot;msg&quot;);</span></span><br><span class="line"><span class="comment">String newMsg = msg.replaceAll(&quot;脏话&quot;, &quot;**&quot;);</span></span><br><span class="line"><span class="comment">map.put(&quot;msg&quot;, newMsg);*/</span></span><br><span class="line"><span class="comment">/*控制视图*/</span></span><br><span class="line"><span class="comment">/*modelAndView.setViewName(&quot;/testDemo1.jsp&quot;);*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-4-afterCompletion方法"><a href="#4-4-afterCompletion方法" class="headerlink" title="4.4 afterCompletion方法"></a>4.4 afterCompletion方法</h3><ul><li><p>执行时机：在进行页面渲染的时候执行</p></li><li><p>调用：按拦截器定义逆序调用</p></li><li><p>作用：在<code>DispatcherServlet </code>完全处理完请求后被调用,可以在该方法中进行一些资源清理的操作。</p></li><li><p>参数：</p><ul><li><code>HttpServletRequest arg0</code>，拦截的请求的<code>request</code>对象</li><li><code>HttpServletResponse arg1</code>，拦截的请求的<code>response</code>对象</li><li><code>Object arg2</code>，封存了单元方法对象的<code>HandleMethod</code>对象</li><li><code>Exception arg3</code>，存储了责任链的异常信息</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论controller是否出现异常,都会执行的方法</span></span><br><span class="line"><span class="comment"> *  一般来说都做一些资源释放工作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">/*页面渲染完毕,但是还没有给浏览器响应数据的时候*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor afterCompletion&quot;</span>);</span><br><span class="line">System.out.println(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、其他注解"><a href="#5、其他注解" class="headerlink" title="5、其他注解"></a>5、其他注解</h2><h3 id="5-1-PostMapping"><a href="#5-1-PostMapping" class="headerlink" title="5.1 @PostMapping"></a>5.1 @PostMapping</h3><ul><li>作用：指定当前发送请求的方式只可以是<code>post</code>请求</li><li>属性：和<code>@RequestMapping</code>中属性一致</li></ul><h3 id="5-2-GetMapping"><a href="#5-2-GetMapping" class="headerlink" title="5.2 @GetMapping"></a>5.2 @GetMapping</h3><ul><li>作用：指定当前发送请求的方式只可以是<code>get</code>请求</li><li>属性：和<code>@RequestMapping</code>中属性一致</li></ul><h3 id="5-3-JsonFormat"><a href="#5-3-JsonFormat" class="headerlink" title="5.3 @JsonFormat"></a>5.3 @JsonFormat</h3><ul><li>作用：处理响应json 数据的处理</li><li>属性：<ul><li>pattern ：指定响应时间日期的格式</li><li>Timezone：指定响应的时区，否则会有8个小时的时间差</li></ul></li></ul><h3 id="5-4-RequestBody"><a href="#5-4-RequestBody" class="headerlink" title="5.4 @RequestBody"></a>5.4 @RequestBody</h3><ul><li>作用：用于获取请求体<code>json</code>格式的字符串内容。直接使用得到是 <code>key=value&amp;key=value</code>结构的数据，<code>get </code>请求方式不适用。</li><li>属性：<code>required</code>：是否必须有请求体。默认值是:<code>true</code>。当取值为 <code>true </code>时，<code>get </code>请求方式会报错。如果取值 为 <code>false</code>，<code>get</code> 请求得到是<code>null</code>。</li></ul><h3 id="5-5-CrossOrigin"><a href="#5-5-CrossOrigin" class="headerlink" title="5.5 @CrossOrigin"></a>5.5 @CrossOrigin</h3><p>​<strong>跨域</strong>：出于浏览器的同源策略限制。同源策略（<code>SameOriginPolicy</code>）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说<code>Web</code>是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的<code>javascript</code>脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（<code>protocol</code>），主机（<code>host</code>）和端口号（<code>port</code>） </p><ul><li><p>作用：解决ajax请求之间的跨域问题</p></li><li><p>属性：</p><ul><li>origins：允许可访问的域列表IP</li><li>maxAge：准备响应前的缓存持续的最大时间（以秒为单位）。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">receive</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Springmvc学习&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Springmvc" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/Springmvc/"/>
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Springmvc" scheme="https://lyblog2022.github.io/tags/Springmvc/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://lyblog2022.github.io/2022/06/04/study/Spring/"/>
    <id>https://lyblog2022.github.io/2022/06/04/study/Spring/</id>
    <published>2022-06-04T08:59:55.000Z</published>
    <updated>2022-06-06T04:53:57.256Z</updated>
    
    <content type="html"><![CDATA[<p>Spring学习</p><span id="more"></span><h2 id="1、Spring框架"><a href="#1、Spring框架" class="headerlink" title="1、Spring框架"></a>1、<code>Spring</code>框架</h2><h3 id="1-1-Spring框架"><a href="#1-1-Spring框架" class="headerlink" title="1.1 Spring框架"></a>1.1 <code>Spring</code>框架</h3><p>​<code>Spring</code>框架是由于软件开发的复杂性而创建的。<code>Spring</code>使用的是基本的<code>JavaBean</code>来完成以前只可能由<code>EJB</code>完成的事情。然而，<code>Spring</code>的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分<code>Java</code>应用都可以从<code>Spring</code>中受益。</p><p>​—-百度百科</p><ul><li>目的：解决企业应用开发的复杂性</li><li>功能：使用基本的<code>JavaBean</code>代替<code>EJB</code>，并提供更对的企业应用功能</li><li>范围：任何<code>Java</code>应用</li></ul><p>​<code>Spring</code>是分层的全栈式的轻量级开发框架，以<code>IOC</code>和<code>AOP</code>为核心</p><h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ol><li>方便解耦，简化开发</li></ol><p><code>Spring</code>通过容器，将对象的创建从代码中剥离出来，交给<code>Spring</code>控制，避免直接编码造成模块之间的耦合度高，用户也不必自己编码处理对象的单例和多例控制，主要关注接口功能即可，不用关注具体使用哪个实现类和实现细节问题 </p><ol start="2"><li><code>AOP</code>切面编程</li></ol><p><code>AOP</code>切面编程是程序设计的一种概念，<code>Spring</code>对该概念实现的比较好，通过切面编程我们可以在不修改原有代码的情况下实现功能的增加，通常用于事务控制、日志记录、性能检测、权限控制等等</p><ol start="3"><li>声明式事务</li></ol><p>事务的控制可以托管给<code>Spring</code>，我们通过注解或者配置文件声明事务的处理方式即可，不用我们自己去编码处理</p><ol start="4"><li>整合<code>JUNIT</code>，方便测试</li></ol><p><code>spring</code>整合<code>JUNIT</code>单元测试，对于项目的功能都可以进行轻松快速的测试，便于我们调试程序</p><ol start="5"><li>方便整合各种优秀的框架</li><li>丰富的功能封装</li></ol><p><code>spring</code>对<code>JAVAEE</code>(<code>JDBC </code>，<code>JAVAMail</code>)都进行了一系列的封装，简化我们对于<code>API</code>的使用，提高程序的开发效率</p><ol start="7"><li>规范的源码学习样本</li></ol><p><code>spring</code>的源码设计巧妙，结构清晰，大量使用了设计模式，是<code>java</code>代码规范编写的典范</p><h2 id="2、Spring模块"><a href="#2、Spring模块" class="headerlink" title="2、Spring模块"></a>2、<code>Spring</code>模块</h2><img src="/2022/06/04/study/Spring/Spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" class="" title="Spring体系结构 image"><h3 id="2-1-Data-Access-Integration（数据访问／集成）"><a href="#2-1-Data-Access-Integration（数据访问／集成）" class="headerlink" title="2.1 Data Access/Integration（数据访问／集成）"></a>2.1 <code>Data Access/Integration</code>（数据访问／集成）</h3><p>数据访问&#x2F;集成层包括 <code>JDBC</code>、<code>ORM</code>、<code>OXM</code>、JMS<code> </code>和 <code>Transactions </code>模块</p><ul><li><p><code>JDBC </code>模块：提供了一个 <code>JDBC </code>的抽象层，大幅度减少了在开发过程中对数据库操作的编码。</p></li><li><p><code>ORM </code>模块：对流行的对象关系映射 <code>API</code>，包括 <code>JPA</code>、<code>JDO</code>、<code>Hibernate</code>和 <code>iBatis </code>提供了的集成层。</p></li><li><p><code>OXM </code>模块：提供了一个支持对象<code>XML </code>映射的抽象层实现，如 <code>JAXB</code>、<code>Castor</code>、<code>XMLBeans</code>、<code>JiBX </code>和 <code>XStream</code>。 </p></li><li><p><code>JMS </code>模块：指<code>JAVA</code>消息服务，包含的功能为生产和消费的信息。</p></li><li><p><code>Transactions </code>事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 <code>POJO</code>。</p></li></ul><h3 id="2-2-Web-模块"><a href="#2-2-Web-模块" class="headerlink" title="2.2  Web 模块"></a>2.2  <code>Web </code>模块</h3><p><code>Spring </code>的 <code>Web </code>层包括 <code>Web</code>、<code>Servlet</code>、<code>Struts </code>和 <code>Portlet </code>组件</p><ul><li><code>Web </code>模块：提供了基本的 <code>Web </code>开发集成特性，例如多文件上传功能、使用的 <code>Servlet </code>监听器的 <code>IoC </code>容器初始化以及 <code>Web </code>应用上下文。</li><li><code>Servlet</code>模块：包括 <code>Spring </code>模型—视图—控制器（<code>MVC</code>）实现 <code>Web</code>应用程序。</li><li><code>Struts </code>模块：包含支持类内的 <code>Spring </code>应用程序，集成了经典的 <code>Struts Web</code> 层。</li><li><code>Portlet </code>模块：提供了在 <code>Portlet </code>环境中使用 <code>MVC</code>实现，类似 <code>Web-Servlet</code> 模块的功能。</li></ul><h3 id="2-3-Core-Container（核心容器）"><a href="#2-3-Core-Container（核心容器）" class="headerlink" title="2.3 Core Container（核心容器）"></a>2.3 <code>Core Container</code>（核心容器）</h3><p><code>Spring </code>的核心容器是其他模块建立的基础，由 <code>Beans </code>模块、<code>Core </code>核心模块、<code>Context </code>上下文模块和 <code>Expression Language</code> 表达式语言模块组成</p><ul><li><code>Beans </code>模块：提供了 <code>BeanFactory</code>，是工厂模式的经典实现，<code>Spring </code>将管理对象称为 <code>Bean</code>。</li><li><code>Core </code>核心模块：提供了 <code>Spring </code>框架的基本组成部分，包括 <code>IoC </code>和 <code>DI </code>功能。</li><li><code>Context </code>上下文模块：建立在核心和 <code>Beans</code> 模块的基础之上，它是访问定义和配置任何对象的媒介。<code>ApplicationContext </code>接口是上下文模块的焦点。</li><li><code>Expression Language</code> 模块：是运行时查询和操作对象图的强大的表达式语言。</li></ul><h3 id="2-4-其他模块"><a href="#2-4-其他模块" class="headerlink" title="2.4 其他模块"></a>2.4 其他模块</h3><p><code>Spring</code>的其他模块还有 <code>AOP</code>、<code>Aspects</code>、<code>Instrumentation </code>以及 <code>Test </code>模块</p><ul><li><code>AOP </code>模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。</li><li><code>Aspects </code>模块：提供与 <code>AspectJ </code>的集成，是一个功能强大且成熟的面向切面编程（<code>AOP</code>）框架。</li><li><code>Instrumentation </code>模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li><code>Test </code>模块：支持 <code>Spring </code>组件，使用 <code>JUnit </code>或 <code>TestNG </code>框架的测试。</li></ul><h2 id="3、Spring-IOC"><a href="#3、Spring-IOC" class="headerlink" title="3、Spring_IOC"></a>3、Spring_IOC</h2><h3 id="3-1-控制反转"><a href="#3-1-控制反转" class="headerlink" title="3.1 控制反转"></a>3.1 控制反转</h3><p>​控制反转（Inversion of Control，缩写为<strong>IoC</strong>），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做<strong>依赖注入</strong>（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫<strong>依赖查找</strong>（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。–【百度】</p><p>​简单来说，创建对象的权利，或者是控制的位置，由<code>Java</code>代码转移到<code>Spring</code>容器，由<code>Spring</code>的容器控制对象的创建，就是控制反转，<code>Spring</code>创建对象时，会读取配置文件中的信息，然后使用反射创建好的对象之后在容器中存储起来，当需要某个对象时，通过<code>id</code>获取对象即可，不需要自己去<code>new</code></p><h3 id="3-2-原理分析"><a href="#3-2-原理分析" class="headerlink" title="3.2 原理分析"></a>3.2 原理分析</h3><h4 id="3-2-1-XML解析"><a href="#3-2-1-XML解析" class="headerlink" title="3.2.1 XML解析"></a>3.2.1 XML解析</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stuDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dao.impl.StuDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​将上面的信息读取进入程序  对象的ID ,一个是对象的类的全路径名</p><h4 id="3-2-2-反射"><a href="#3-2-2-反射" class="headerlink" title="3.2.2 反射"></a>3.2.2 反射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得类的字节码</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>Class.forName(<span class="string">&quot;com.dao.impl.StuDaoImpl&quot;</span>);</span><br><span class="line"><span class="comment">//通过字节码实例化对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span>  <span class="operator">=</span> clazz.newInstance(); </span><br><span class="line"><span class="comment">//将对象放到一个map集合中</span></span><br><span class="line">map.put(<span class="string">&quot;empDao&quot;</span>,obj)</span><br></pre></td></tr></table></figure><h4 id="3-2-3-工厂模式"><a href="#3-2-3-工厂模式" class="headerlink" title="3.2.3 工厂模式"></a>3.2.3 工厂模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span>&#123; </span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span>map.get(name); </span><br><span class="line">    <span class="keyword">return</span> obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IOC</code>接口</p><ul><li><code>BeanFactory </code>接口：<code>IOC</code>容器基本功能接口，是<code>spring</code>内部使用的接口，我们在处理业务时一般不直接使用该接口</li><li><code>ApplicationContext </code>接口：<code>BeanFactory</code>的子接口，提供更多更强大的功能，研发人员一般使用的接口</li></ul><img src="/2022/06/04/study/Spring/spring2.png" class="" title="spring2 image"><h2 id="4、Spring-XML方式实现DI"><a href="#4、Spring-XML方式实现DI" class="headerlink" title="4、Spring_XML方式实现DI"></a>4、<code>Spring_XML</code>方式实现<code>DI</code></h2><p><code>spring</code>中的<code>Bean</code>的管理: </p><p><code>Bean</code>(汉译咖啡豆)，又称<code>JAVABean</code>，其实就是<code>JAVA</code>程序程序中的一个个对象，所以<code>Bean</code>的管理其实就是<code>spring</code>对于<code>JAVA</code>程序中的对象的管理</p><p>管理的内容</p><ul><li>对象的创建（<code>IOC</code>）：控制反转，就是<code>Spring</code>给我们创建对象，然后我们直接用，不用自己<code>NEW</code></li><li>属性的赋值（<code>DI</code>）：依赖注入，即创建属性时给对象属性赋值，对象功能的实现往往要依赖属性的值，由于对象属性不仅仅是基本数据类型，还可能是其他类或者引用类型，那么依赖注入将会把更多的对象之间的关系整理到一起，可以形成一个庞大的依赖关系，DI处理的是对象的属性赋值和互相依赖的关系</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过无参构造方法构造对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bean.User&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">id:对象的id</span></span><br><span class="line"><span class="comment">class:类的全路径名</span></span><br><span class="line"><span class="comment">name:和id类似,一般不用</span></span><br><span class="line"><span class="comment">scope：控制对象单例多例和使用范围</span></span><br><span class="line"><span class="comment">singleton：作用域(scope 默认值), Spring IOC容器中只会存在一个共享的bean实例</span></span><br><span class="line"><span class="comment">prototype：作用域部署的bean，每一次获取都会产生一个新的bean实例，相当与一个new的操作</span></span><br><span class="line"><span class="comment">request：表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</span></span><br><span class="line"><span class="comment">session：作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效</span></span><br><span class="line"><span class="comment">global session：作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义</span></span><br><span class="line"><span class="comment">lazy-init：懒加载 调用getBean的时候再去实例化对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通过set方法给对象属性赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bean.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userid&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abcdefg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通过有参构造给对象属性赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bean.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userid&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456789&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--特殊符号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bean.User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--null值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userid&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">null</span>&gt;</span><span class="tag">&lt;/<span class="name">null</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--特殊符号 转译字符 &lt; &amp;lt;  &gt;&amp;gt;  &amp; &amp;amp;     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;amp;</span>xiaoming<span class="symbol">&amp;lt;</span><span class="symbol">&amp;gt;</span>&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 特殊符号  &lt;![CDATA[内容]]&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&amp;&lt;123456&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5、Spring-Bean生命周期"><a href="#5、Spring-Bean生命周期" class="headerlink" title="5、Spring_Bean生命周期"></a>5、<code>Spring_Bean</code>生命周期</h2><ol><li>通过构造器创建bean实例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  执行构造器</li><li>为bean属性赋值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  执行set方法</li><li>初始化bean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 调用bean的初始化方法,需要配置指定调用的方法</li><li>bean的获取&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 容器对象 getBean方法</li><li>容器关闭销毁bean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 调用销毁方法,需要配置指定调用的方法</li></ol><h2 id="6、Spring注解方式管理Bean"><a href="#6、Spring注解方式管理Bean" class="headerlink" title="6、Spring注解方式管理Bean"></a>6、<code>Spring</code>注解方式管理<code>Bean</code></h2><h3 id="6-1-注解方式创建对象IOC"><a href="#6-1-注解方式创建对象IOC" class="headerlink" title="6.1 注解方式创建对象IOC"></a>6.1 注解方式创建对象<code>IOC</code></h3><ul><li>@Component：放在类上,用于标记，告诉<code>spring</code>当前类需要由容器实例化<code>bean</code>并放入容器中</li><li>@Controller：@Component子注解，用于实例化<code>controller</code>层<code>bean</code></li><li>@Service：@Component子注解，用于实例化<code>service</code>层<code>bean</code></li><li>@Repository：@Component子注解，用于实例化持久层<code>bean</code></li></ul><h3 id="6-2-注解方式依赖注入DI"><a href="#6-2-注解方式依赖注入DI" class="headerlink" title="6.2 注解方式依赖注入DI"></a>6.2 注解方式依赖注入<code>DI</code></h3><ul><li>@Autowired：根据属性数据类型自动装配</li><li>@Qualifier：根据属性名称注入依赖</li><li>@Resources：可以根据类型,也可以根据名称注入</li><li>@Value：注入普通数据类型(8+String)</li></ul><h2 id="7、Spring代理"><a href="#7、Spring代理" class="headerlink" title="7、Spring代理"></a>7、<code>Spring</code>代理</h2><h3 id="7-1-代理模式"><a href="#7-1-代理模式" class="headerlink" title="7.1 代理模式"></a>7.1 代理模式</h3><p>通过代理对象访问目标对象，可以在目标对象基础上增强额外的功能，如添加权限、访问控制等</p><img src="/2022/06/04/study/Spring/spring%E4%BB%A3%E7%90%86.png" class="" title="spring代理 image"><h3 id="7-2-静态代理"><a href="#7-2-静态代理" class="headerlink" title="7.2 静态代理"></a>7.2 静态代理</h3><p>​静态代理中代理类与被代理类都需要实现同一个接口，即一个静态代理类只能代理一个类，并且需要知道要代理哪个类才能编写代理类代码，如果有其他类想要使用代理类，就必须再写一个</p><p>​在实际开发中是可能有非常多的类需要被代理，并且可能并不知道要代理哪个类，所以继续使用静态代理反而会增加更多的工作量，且效率低下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: Ly</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">Court court=<span class="keyword">new</span> <span class="title class_">Lawyer</span>(person);</span><br><span class="line">court.doCourt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Court</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doCourt</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lawyer</span> <span class="keyword">implements</span> <span class="title class_">Court</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Lawyer</span><span class="params">(Person person)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.person = person;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCourt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;律师取证:视频证明张三当时正在旅游,不在案发现场&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;律师总结:张三不可能去杀人&quot;</span>);</span><br><span class="line">person.doCourt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Court</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCourt</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;说:我没有杀人&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="7-3-动态代理"><a href="#7-3-动态代理" class="headerlink" title="7.3 动态代理"></a>7.3 动态代理</h3><p>​动态代理可以针对于一些不特定的类或者一些不特定的方法进行代理，可以在程序运行时动态的改变代理的规则，代理类在程序运行时才创建的代理模式，在这种情况下，代理类并不是在<code>Java</code>代码中定义好，而是在程序运行时根据在<code>Java</code>代码中的指示动态生成的</p><ul><li><code>Proxy</code>动态代理：<code>JDK</code>动态代理，面向接口</li><li><code>cglib</code>动态代理：第三方动态代理，面向父类</li></ul><h4 id="7-3-1-Proxy动态代理"><a href="#7-3-1-Proxy动态代理" class="headerlink" title="7.3.1 Proxy动态代理"></a>7.3.1 <code>Proxy</code>动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testProxy;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Ly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Dinner dinner=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Porxy动态代理获得一个代理对象,在代理对象中,对某个方法进行增强</span></span><br><span class="line"><span class="comment">// ClassLoader loader,被代理的对象的类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> dinner.getClass().getClassLoader();</span><br><span class="line"><span class="comment">// Class&lt;?&gt;[] interfaces,被代理对象所实现的所有接口</span></span><br><span class="line">Class[] interaces= dinner.getClass().getInterfaces();</span><br><span class="line"><span class="comment">//InvocationHandler h,执行处理器对象,专门用于定义增强的规则</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line"><span class="comment">// invoke 当我们让代理对象调用任何方法时,都会触发invoke方法的执行</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//Object proxy, 代理对象</span></span><br><span class="line"><span class="comment">//Method method,被代理的方法</span></span><br><span class="line"><span class="comment">//Object[] args,被代理方法运行时的实参</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;eat&quot;</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;饭前洗手&quot;</span>);</span><br><span class="line"><span class="comment">// 让原有的eat的方法去运行</span></span><br><span class="line">res = method.invoke(dinner, args);</span><br><span class="line">System.out.println(<span class="string">&quot;饭后刷碗&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果是其他方法,那么正常执行就可以了</span></span><br><span class="line">res = method.invoke(dinner, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Dinner</span> <span class="variable">dinnerProxy</span> <span class="operator">=</span>(Dinner) Proxy.newProxyInstance(classLoader,interaces,handler);</span><br><span class="line"><span class="comment">//dinnerProxy.eat(&quot;包子&quot;);</span></span><br><span class="line">dinnerProxy.drink();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dinner</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String foodName)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Dinner</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String foodName)</span> &#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;正在吃&quot;</span>+foodName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;正在喝茶&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Dinner</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String foodName)</span> &#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;正在食堂吃&quot;</span>+foodName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;正在喝可乐&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​总结：</p><ul><li>在不修改原有代码的或者没有办法修改原有代码的情况下，增强对象功能使用代理对象代替原来的对象去完成功能，进而达到拓展功能的目的</li><li><code>JDK Proxy</code>动态代理是面向接口的动态代理，一定要有接口和实现类，代理对象增强的是实现类，在实现接口的方法重写方法，生成的代理对象只能转换成接口，不能转换成代理类<ul><li>生成的代理对象只能转换成接口，不能转换成被代理类</li><li>代理对象只能增强接口中定义的方法，实现类中其他和接口无关的方法是无法增强的</li><li>代理对象只能读取到接口中方法上的注解，不能读取到实现类方法上的注解</li></ul></li></ul><h4 id="7-3-2-cglib动态代理模式"><a href="#7-3-2-cglib动态代理模式" class="headerlink" title="7.3.2 cglib动态代理模式"></a>7.3.2 <code>cglib</code>动态代理模式</h4><img src="/2022/06/04/study/Spring/cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" class="" title="cglib动态代理 image"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testCglib; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy; </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Ly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCglib</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">// 获取一个Person的代理对象</span></span><br><span class="line"><span class="comment">// 1 获得一个Enhancer对象</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line"><span class="comment">// 2 设置父类字节码</span></span><br><span class="line">enhancer.setSuperclass(person.getClass());</span><br><span class="line"><span class="comment">// 3 获取MethodIntercepter对象 用于定义增强规则</span></span><br><span class="line"><span class="type">MethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">/*  Object o,  生成之后的代理对象 personProxy</span></span><br><span class="line"><span class="comment">Method method,  父类中原本要执行的方法  Person&gt;&gt;&gt; eat()</span></span><br><span class="line"><span class="comment">Object[] objects, 方法在调用时传入的实参数组</span></span><br><span class="line"><span class="comment">MethodProxy methodProxy  子类中重写父类的方法 personProxy &gt;&gt;&gt; eat()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;eat&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">// 如果是eat方法 则增强并运行</span></span><br><span class="line">System.out.println(<span class="string">&quot;饭前洗手&quot;</span>);</span><br><span class="line">res = methodProxy.invokeSuper(o,objects);</span><br><span class="line">System.out.println(<span class="string">&quot;饭后刷碗&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果是其他方法 不增强运行</span></span><br><span class="line">res = methodProxy.invokeSuper(o,objects); <span class="comment">// 子类对象方法在执行,默认会调用父类对应被重写的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 4 设置methodInterceptor</span></span><br><span class="line">enhancer.setCallback(methodInterceptor);</span><br><span class="line"><span class="comment">// 5 获得代理对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">personProxy</span> <span class="operator">=</span> (Person)enhancer.create();</span><br><span class="line"><span class="comment">// 6 使用代理对象完成功能</span></span><br><span class="line">personProxy.eat(<span class="string">&quot;包子&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>  &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String foodName)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;张三正在吃&quot;</span>+foodName);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="8、Spring-AOP"><a href="#8、Spring-AOP" class="headerlink" title="8、Spring AOP"></a>8、<code>Spring AOP</code></h2><h3 id="8-1-AOP-概念及原理"><a href="#8-1-AOP-概念及原理" class="headerlink" title="8.1 AOP 概念及原理"></a>8.1 <code>AOP </code>概念及原理</h3><p>​在软件业，<code>AOP</code>为<code>Aspect Oriented Programming</code>的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。<code>AOP</code>是<code>OOP</code>的延续，是软件开发中的一个热点，也是<code>Spring</code>框架中的一个重要内容，是函数式编程的一种衍生范型。利用<code>AOP</code>可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。—-【百度百科】</p><p>​<code>AOP </code>面向切面编程一般可以在不修改现有代码的情况下，对程序功能进行拓展，往往用于实现日志处理、权限控制、性能检测、事务控制等</p><p>​AOP实现的原理就是<strong>动态代理</strong>，在有接口的情况下，使用**<code>JDK</code>动态代理<strong>，在没有接口的情况下使用</strong><code>cglib</code>动态代理**</p><h3 id="8-2-术语"><a href="#8-2-术语" class="headerlink" title="8.2 术语"></a>8.2 术语</h3><ol><li>连接点（<code>Joint point</code>）：类里面可以被增强的方法，这些方法称之为<strong>连接点</strong>，表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等待，它自身还可以嵌套其他<code>Join point</code></li><li>切入点（<code>Pointcut</code>）：实际被增强的方法，称之为切入点，表示一组<code>joint point</code>，这些<code>joint point</code>或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的<code>Advince</code>将要发生的地方</li><li>通知（<code>Advince</code>）：实际增强的逻辑部分称为通知（增加的功能），<code>Advince</code>定义了在<code>Pointcut</code>里面定义的程序点具体要做的操作，它通过<code>before</code>、<code>after</code>、<code>around</code>来区别是在每个<code>joint point</code>之前、之后还是代替执行的代码，通知类型：前置通知、后置通知、环绕通知、异常通知、最终通知</li><li>目标对象（<code>Target</code>）：被增强功能的对象（被代理的对象）</li><li>切面（<code>Aspect</code>）：表现为功能相关的一些advice放在一起声明成为一个<code>java</code>类，<code>aspect</code>声明类似与<code>java</code>的类声明，在<code>aspect</code>中会包含一些<code>pointcut</code>以及相应的<code>advince</code></li><li>织入（<code>Weaving</code>）：创建代理对象并实现功能增强的声明并运行的过程，将<code>Aspect</code>和其他对象链接起来，并创建<code>Advince Object</code>的过程</li></ol><h3 id="8-3-注解方式实现"><a href="#8-3-注解方式实现" class="headerlink" title="8.3 注解方式实现"></a>8.3 注解方式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aspect;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Ly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAspect</span> &#123;</span><br><span class="line">    <span class="comment">//定义公共切点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.dao.*.add*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPointCut</span><span class="params">()</span> &#123;&#125;. </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 前置通知: 切点方法执行之前先执行的功能</span></span><br><span class="line"><span class="comment">    * 参数列表可以用JoinPoint接收切点对象</span></span><br><span class="line"><span class="comment">    * 可以获取方法执行的参数</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Before(&quot;addPointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invoked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 后置通知:方法执行之后要增强的功能</span></span><br><span class="line"><span class="comment">    * 无论切点方法是否出现异常都会执行的方法</span></span><br><span class="line"><span class="comment">    * 参数列表可以用JoinPoint接收切点对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@After(&quot;addPointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After invoked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 返回通知:切点方法正常运行结束后增强的功能</span></span><br><span class="line"><span class="comment">     * 如果方法运行过程中出现异常,则该功能不运行</span></span><br><span class="line"><span class="comment">     * 参数列表可以用 JoinPoint joinPoint接收切点对象</span></span><br><span class="line"><span class="comment">     * 可以用Object res接收方法返回值,需要用returning指定返回值名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@AfterReturning( value = &quot;addPointCut()&quot;,returning = &quot;res&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodAfterReturning</span><span class="params">(JoinPoint joinPoint, Object res)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterReturning invoked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 异常通知:切点方法出现异常时运行的增强功能</span></span><br><span class="line"><span class="comment">     * 如果方法运行没有出现异常,则该功能不运行</span></span><br><span class="line"><span class="comment">     * 参数列表可以用Exception ex接收异常对象 需要通过throwing指定异常名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@AfterThrowing( value = &quot;addPointCut()&quot;,throwing = &quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodAfterThrowing</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterThrowing invoked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*环绕通知:在切点方法之前和之后都进行功能的增强</span></span><br><span class="line"><span class="comment">    * 需要在通知中定义方法执行的位置,并在执行位置之前和之后自定义增强的功能</span></span><br><span class="line"><span class="comment">    * 方法列表可以通过ProceedingJoinPoint获取执行的切点</span></span><br><span class="line"><span class="comment">    * 通过proceedingJoinPoint.proceed()方法控制切点方法的执行位置</span></span><br><span class="line"><span class="comment">    * proceedingJoinPoint.proceed()方法会将切点方法的返回值获取到,并交给我们,可以做后续处理</span></span><br><span class="line"><span class="comment">    * 我们在环绕通知的最后需要将切点方法的返回值继续向上返回,否则切点方法在执行时接收不到返回值</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Around(&quot;addPointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">methodAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aroundA invoked&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;aroundB invoked&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​有多个增强类对同一个方法进行增强，通过<code>@Order</code>注解设置增强类优先级，数字越小，优先级越高，数字越小，其代理位置越靠近注入位置</p><h2 id="9、Spring-事务"><a href="#9、Spring-事务" class="headerlink" title="9、Spring 事务"></a>9、<code>Spring </code>事务</h2><h3 id="9-1-事务"><a href="#9-1-事务" class="headerlink" title="9.1 事务"></a>9.1 事务</h3><p>​事务（<code>Transaction</code>）：指的是一个操作序列，该操作序列中的多个操作，只能都做，或者都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，由<code>DBMS</code>中的事务管理子系统负责事务的处理</p><p>​但并不是所有的操作序列都可以称为为事务，因为一个操作序列成为事务，必须满足事务的四个特性，即原子性（<code>Atomicity</code>）、一致性（<code>Consistency</code>）、隔离性（<code>Isolation</code>）、持久性（<code>Durability</code>）&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<code>ACID</code>特性</p><h4 id="9-1-1-原子性"><a href="#9-1-1-原子性" class="headerlink" title="9.1.1 原子性"></a>9.1.1 原子性</h4><p>​原子是自然界最小的颗粒，具有不可再分的特性。事务中的所有操作可以看做一个原子，事务是应用中不可再分的最小的逻辑执行体。</p><p>​使用事务对数据进行修改的操作序列，要么全部执行，要么全不执行。通常，某个事务中的操作都具有共同的目标，并且是相互依赖的。如果数据库系统只执行这些操作中的一部分，则可能会破坏事务的总体目标，而原子性消除了系统只处理部分操作的可能性。</p><h4 id="9-1-2-一致性"><a href="#9-1-2-一致性" class="headerlink" title="9.1.2 一致性"></a>9.1.2 一致性</h4><p>​一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。</p><p>​例如：在转账时，只有保证转出和转入的金额一致才能构成事务。也就是说事务发生前和发生后，数据的总额依然匹配。</p><h4 id="9-1-3-隔离性"><a href="#9-1-3-隔离性" class="headerlink" title="9.1.3 隔离性"></a>9.1.3 隔离性</h4><p>​隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。</p><p>​例如：在转账时，只有当A账户中的转出和B账户中转入操作都执行成功后才能看到A账户中的金额减少以及B账户中的金额增多。并且其他的事务对于转账操作的事务是不能产生任何影响的。</p><h4 id="9-1-4-持久性"><a href="#9-1-4-持久性" class="headerlink" title="9.1.4 持久性"></a>9.1.4 持久性</h4><p>​持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。</p><h3 id="9-2-事务的并发问题"><a href="#9-2-事务的并发问题" class="headerlink" title="9.2 事务的并发问题"></a>9.2 事务的并发问题</h3><h4 id="9-2-1-脏读（Dirty-read）"><a href="#9-2-1-脏读（Dirty-read）" class="headerlink" title="9.2.1 脏读（Dirty read）"></a>9.2.1 脏读（<code>Dirty read</code>）</h4><p>​当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p><h4 id="9-2-2-不可重复读（Unrepeatableread）"><a href="#9-2-2-不可重复读（Unrepeatableread）" class="headerlink" title="9.2.2 不可重复读（Unrepeatableread）"></a>9.2.2 不可重复读（<code>Unrepeatableread</code>）</h4><p>​ 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><h4 id="9-2-3-幻读（Phantom-read）"><a href="#9-2-3-幻读（Phantom-read）" class="headerlink" title="9.2.3 幻读（Phantom read）"></a>9.2.3 幻读（<code>Phantom read</code>）</h4><p>​幻读与不可重复读类似。它发生在一个事务（<code>T1</code>）读取了几行数据，接着另一个并发事务（<code>T2</code>）插入了一些数据时。在随后的查询中，第一个事务（<code>T1</code>）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><h4 id="9-2-4-总结"><a href="#9-2-4-总结" class="headerlink" title="9.2.4 总结"></a>9.2.4 总结</h4><p>​不可重复读的重点是修改，幻读的重点在于新增或者删除</p><p>​解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表</p><h4 id="9-2-5-事务的隔离级别"><a href="#9-2-5-事务的隔离级别" class="headerlink" title="9.2.5 事务的隔离级别"></a>9.2.5 事务的隔离级别</h4><p>​事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以<code>MySQL</code>中提供了四种隔离级别来解决上述问题。 </p><p>​事务的隔离级别从低到高依次为<code>READ UNCOMMITTED</code>、<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>以及<code>SERIALIZABLE</code>，隔离级别越低，越能支持高并发的数据库操作。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（读未提交）</td><td>true</td><td>true</td><td>true</td></tr><tr><td>READ COMMITTED（读已提交）</td><td>false</td><td>true</td><td>true</td></tr><tr><td>REPEATABLE READ（可重复读）</td><td>false</td><td>false</td><td>true</td></tr><tr><td>SERIALIZABLE（串行化）</td><td>false</td><td>false</td><td>false</td></tr></tbody></table><p>​</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring学习&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Spring" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/Spring/"/>
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Spring" scheme="https://lyblog2022.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="https://lyblog2022.github.io/2022/06/04/study/Servlet/"/>
    <id>https://lyblog2022.github.io/2022/06/04/study/Servlet/</id>
    <published>2022-06-04T08:59:30.000Z</published>
    <updated>2022-06-04T10:16:44.166Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet学习</p><span id="more"></span><h3 id="1、Servlet的继承结构"><a href="#1、Servlet的继承结构" class="headerlink" title="1、Servlet的继承结构"></a>1、Servlet的继承结构</h3><img src="/2022/06/04/study/Servlet/servlet%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" class="" title="This is an example image"><h3 id="2、Servlet接口"><a href="#2、Servlet接口" class="headerlink" title="2、Servlet接口"></a>2、Servlet接口</h3><ul><li>init()：创建servlet对象后立即调用该方法完成其他初始化工作</li><li>service()：处理客户端请求，执行业务操作，利用响应对象响应客户端请求</li><li>destory()：再销毁servlet对象之前调用该方法，释放资源</li><li>getServletConfig()：ServletConfig 是容器向Servlet传递参数的载体</li><li>getServletInfo()：获取servlet相关信息</li></ul><h3 id="3、ServletConfig-接口"><a href="#3、ServletConfig-接口" class="headerlink" title="3、ServletConfig 接口"></a>3、ServletConfig 接口</h3><p>​Servlet运行期间，需要一些辅助信息，这些信息可以在web.xml文件中，使用一个或多个元素进行配置。当tomacat初始化一个servlet时，会将该servlet的配置信息，封装到ServletConfig对象中，通过调用init(ServletConfig servletConfig)方法，将ServletConfig对象传递给Servlet</p><h3 id="4、GenericServlet-抽象类"><a href="#4、GenericServlet-抽象类" class="headerlink" title="4、GenericServlet 抽象类"></a>4、GenericServlet 抽象类</h3><p>​GenericServlet是实现了Servlet接口的抽象类。在GenericServlet中进一步的定义了Servlet接口的具体实现，其设计的目的是为了和应用层协议解耦，再GenericServlet中包含了一个Service抽象方法，可以通过继承GenericServlet并实现Service方法实现请求的处理，但是需要将ServletRequest和ServletResponse 转化为HttpServletRequest和HttpServletResponse</p><h3 id="5、HttpServlet"><a href="#5、HttpServlet" class="headerlink" title="5、HttpServlet"></a>5、HttpServlet</h3><p>​继承自GenericServlet，针对于处理Http协议的请求定制，在HttpServlet的service()方法中已经把ServletRequest和ServletResponse 转化为HttpServletRequest和HttpServletResponse</p><h3 id="6、Servlet的生命周期"><a href="#6、Servlet的生命周期" class="headerlink" title="6、Servlet的生命周期"></a>6、Servlet的生命周期</h3><p>​servlet的生命周期是由容器管理的，分别经历4个阶段</p><table><thead><tr><th>阶段</th><th>字数</th><th>时机</th></tr></thead><tbody><tr><td>创建</td><td>1次</td><td>第一次请求之后</td></tr><tr><td>初始化</td><td>1次</td><td>实例化之后</td></tr><tr><td>执行服务</td><td>多次</td><td>每次请求</td></tr><tr><td>销毁</td><td>1次</td><td>停止服务、</td></tr></tbody></table><h3 id="7、注意事项"><a href="#7、注意事项" class="headerlink" title="7、注意事项"></a>7、注意事项</h3><ul><li>在Servlet中一般不要轻易使用成员变量，可能会造成线程安全问题</li><li>如果要使用，应尽量避免对成员变量产生修改</li><li>如果要产生修改，应注意线程安全问题</li></ul><h3 id="8、ServletContext对象和ServletConfig对象"><a href="#8、ServletContext对象和ServletConfig对象" class="headerlink" title="8、ServletContext对象和ServletConfig对象"></a>8、ServletContext对象和ServletConfig对象</h3><p>​ServletContext叫做Servlet上下文，服务器会为每一个web应用创建一个ServletContext对象，这个对象全局唯一，而且web应用中的所有Servlet都共享这个对象</p><h4 id="8-1、ServletContext对象的作用"><a href="#8-1、ServletContext对象的作用" class="headerlink" title="8.1、ServletContext对象的作用"></a>8.1、ServletContext对象的作用</h4><ul><li>相对路径转为绝对路径</li><li>获取容器的附加信息</li><li>读取配置</li><li>全局容器</li></ul><h4 id="8-2、ServletContext的生命周期"><a href="#8-2、ServletContext的生命周期" class="headerlink" title="8.2、ServletContext的生命周期"></a>8.2、ServletContext的生命周期</h4><p>​当容器启动时会创建ServletContext对象并一直缓存该对象，直到容器关闭后该对象生命周期结束，ServletContext的生命周期非常长，所以在使用全局容器时不建议存放业务数据</p><h4 id="8-3、ServletConfig对象"><a href="#8-3、ServletConfig对象" class="headerlink" title="8.3、ServletConfig对象"></a>8.3、ServletConfig对象</h4><p>​ServletConfig对象对应web.xml文件中的<Servlet>节点，当Tomcat初始化一个Servlet时，会将该Servlet的配置信息，封装到一个ServletConfig对象中，可以通过该对象读取<servlet>节点中的配置信息</p><h3 id="9、请求转发"><a href="#9、请求转发" class="headerlink" title="9、请求转发"></a>9、请求转发</h3><h4 id="9-1-forward转发"><a href="#9-1-forward转发" class="headerlink" title="9.1 forward转发"></a>9.1 forward转发</h4><h5 id="9-1-1-forward转发处理流程"><a href="#9-1-1-forward转发处理流程" class="headerlink" title="9.1.1 forward转发处理流程"></a>9.1.1 forward转发处理流程</h5><ol><li>清空response存放的正在响应正文数据缓冲区</li><li>如果目标资源为Servlet或jsp，就调用他们的service方法，把该方法产生的响应结果发送到客户端；如果目标资源是静态文件中的HTML，就读取文件中的数据把它发送到客户端</li></ol><h5 id="9-1-2-forward处理特点"><a href="#9-1-2-forward处理特点" class="headerlink" title="9.1.2 forward处理特点"></a>9.1.2 forward处理特点</h5><ol><li>由于forward()方法先清空用于存放相应正文的缓冲区，因此源Servlet生成的响应结果不会被发送到客户端，只有目标资源生成的响应结果才会被发送到客户端</li><li>如果源Servlet在进行请求转发之前，已经提交了响应结(flushBuffer()，close()方法)，那么forward()方法会抛出异常，为避免异常，不应该在源servlet中提交响应结果</li></ol><h4 id="9-2-include转发"><a href="#9-2-include转发" class="headerlink" title="9.2 include转发"></a>9.2 include转发</h4><h5 id="9-2-1-include处理流程"><a href="#9-2-1-include处理流程" class="headerlink" title="9.2.1 include处理流程"></a>9.2.1 include处理流程</h5><ol><li>如果目标资源为Servlet或者jsp，就调用他们的service方法，把该方法产生的响应正文添加到源Servlet的响应结果中；如果目标组建为HTML文档，就直接把文档的内容添加到源Servlet的响应结果中</li><li>返回到源Servlet的服务方法中，继续执行后续代码</li></ol><h5 id="9-2-2-include处理特点"><a href="#9-2-2-include处理特点" class="headerlink" title="9.2.2 include处理特点"></a>9.2.2 include处理特点</h5><ol><li>源Servlet与被包含的目标资源的输出数据都会被添加到响应结果中</li><li>在目标资源对响应状态码或者响应开头所做的修改都会被忽略</li></ol><h3 id="10、Cookie对象和HttpSession对象"><a href="#10、Cookie对象和HttpSession对象" class="headerlink" title="10、Cookie对象和HttpSession对象"></a>10、Cookie对象和HttpSession对象</h3><p>​Cookie对象和HttpSession对象的作用是维护客户端浏览器与服务端的会话状态的两个对象，二者的不同是Cookie是通过客户端浏览器实现会话的维持，而HttpSession是通过服务端来实现会话的维持</p><h4 id="10-1-区别"><a href="#10-1-区别" class="headerlink" title="10.1 区别"></a>10.1 区别</h4><ul><li>cookie数据存放在客户的浏览器或系统文件中，httpsession中的数据存放在服务器中</li><li>cookie不安全，httpSession是安全的</li><li>单个cookie保存的数据不能超过4K，httpSession无限制</li></ul><p></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Servlet学习&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="servlet" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/servlet/"/>
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="servlet" scheme="https://lyblog2022.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://lyblog2022.github.io/2022/06/04/study/MyBatis/"/>
    <id>https://lyblog2022.github.io/2022/06/04/study/MyBatis/</id>
    <published>2022-06-04T08:59:00.000Z</published>
    <updated>2022-06-06T09:27:18.439Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis学习</p><span id="more"></span><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><code>Mybatis</code> 是一款优秀的持久层框架，支持定制化<code>SQL</code>、存储过程及高级映射，可以使用简单的<code>XML</code>或注解来配置和映射原生信息</p><p>是一款半自动的持久层的半自动<code>ORM</code>映射框架</p><h3 id="1-1-框架"><a href="#1-1-框架" class="headerlink" title="1.1 框架"></a>1.1 框架</h3><ul><li>框架是一个基本概念上的结构，用于解决或处理复杂的问题。</li><li>使用框架的优点：减少开发时间，降低开发难度，保证设计质量，降低程序员之间的沟通以及日后维护的成本</li><li>框架是一个半成品，已经对基础的代码进行了封装并提供响应的<code>API</code>，开发者再使用框架是直接调用封装好的<code>API</code>，可以省去很多代码编写，从而提升效率和开发速度</li></ul><h3 id="1-2-ORM"><a href="#1-2-ORM" class="headerlink" title="1.2 ORM"></a>1.2 <code>ORM</code></h3><ul><li><code>Object-Relation Mapping</code>，对象关系映射</li><li>它的作用是在关系型数据库和对象之间做一个映射，这样在操作具体数据的时候就像操作对象一样</li></ul><h4 id="1-2-1-持久化"><a href="#1-2-1-持久化" class="headerlink" title="1.2.1 持久化"></a>1.2.1 持久化</h4><ul><li>持久：把数据保存到可永久保存的存储设备中</li><li>主要应用：将内存中的数据存储在关系型数据库中</li></ul><h4 id="1-2-2-持久层"><a href="#1-2-2-持久层" class="headerlink" title="1.2.2 持久层"></a>1.2.2 持久层</h4><ul><li>专注于实现数据持久化应用领域的某一个特定系统的一个逻辑层面，将数据使用者和数据实体想关联（<code>mapper</code>层、<code>DAO</code>层）</li></ul><h2 id="2、Mybatis配置"><a href="#2、Mybatis配置" class="headerlink" title="2、Mybatis配置"></a>2、<code>Mybatis</code>配置</h2><h3 id="2-1-事务"><a href="#2-1-事务" class="headerlink" title="2.1 事务"></a>2.1 事务</h3><p>​在<code>MyBatis</code> 核心配置文件中<code>envirment</code> 中通过<code>transactionManager</code>配置事务的处理策略</p><ul><li><code>JDBC</code>：该配置使用了<code>JDBC</code>的提交及回滚，依赖于从数据源得到的链接来管理事务范围</li><li><code>MANAGED</code>：该配置几乎无任何操作，不提交或回滚一个链接，它会让容器来管理整个生命周期（<code>Spring</code>应用服务器的上下文），默认情况下会关闭链接，但一些容器不希望如此，因此如果需要从链接中停止它，将<code>closeConnection</code>的属性值设置为<code>false</code>，<code>Mybatis</code>本身并不会处理事务，而是交给其他框架去处理</li></ul><h3 id="2-2-映射文件的加载方式"><a href="#2-2-映射文件的加载方式" class="headerlink" title="2.2 映射文件的加载方式"></a>2.2 映射文件的加载方式</h3><ol><li><code>mapper</code>的映射文件的文件路径导入，使用的是<code>mapper</code>标签的<code>resource</code>属性</li><li>网络资源路径使用的是<code>mapper</code>的<code>url</code>属性</li><li>接口的全限定名导入使用的是<code>mapper</code>标签的<code>class</code>属性—–基于接口的代理模式</li><li>包扫描形式加载所有的<code>mapper</code>映射文件，使用的<code>package</code>标签</li></ol><h2 id="3、Mybatis-开发"><a href="#3、Mybatis-开发" class="headerlink" title="3、Mybatis 开发"></a>3、<code>Mybatis</code> 开发</h2><h3 id="3-1-传递参数"><a href="#3-1-传递参数" class="headerlink" title="3.1 传递参数"></a>3.1 传递参数</h3><ul><li><p><em>${} 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置</em></p></li><li><p>#{} 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理，更常用</p></li></ul><h2 id="4、MyBatis代理模式开发"><a href="#4、MyBatis代理模式开发" class="headerlink" title="4、MyBatis代理模式开发"></a>4、<code>MyBatis</code>代理模式开发</h2><p>在<code>MyBatis</code>中提供了一种称为<code>Mapper</code>代理（接口绑定）的操作方式，在实际开发中也使用该方式</p><h3 id="4-1-原理浅析"><a href="#4-1-原理浅析" class="headerlink" title="4.1 原理浅析"></a>4.1 原理浅析</h3><p>​底层使用了动态代理模式，动态创建一个<code>Mapper</code>的一个代理对象并赋给接口使用</p><h2 id="5、动态SQL"><a href="#5、动态SQL" class="headerlink" title="5、动态SQL"></a>5、动态<code>SQL</code></h2><p>​<code>MyBatis</code>在简化操作方法上提出了动态<code>SQL</code>功能，将使用<code>Java</code>代码拼接<code>SQL</code>语句，改变为在<code>XML</code>映射文件中截止标签拼接<code>SQL</code>语句。相比而言，大大减少代码量，更灵活、有利于后期维护</p><p>​<code>MyBatis</code>中动态<code>SQL</code>是编写在<code>mapper.xml</code>中的，其语法和<code>JSTL</code>类似，但是却是基于强大的<code>OGNL</code>表达式实现的</p><p>​<code>MyBatis</code>也可以在注解中配置<code>SQL</code>，但是由于注解功能受限，尤其是对于复杂的<code>SQL</code>语句，可读性很差，所以较少使用</p><h3 id="5-1-If标签"><a href="#5-1-If标签" class="headerlink" title="5.1 If标签"></a>5.1 <code>If</code>标签</h3><p>条件查询，符合<code>if</code>的条件，则补充<code>SQL</code>语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student where 1=1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuno != null&quot;</span>&gt;</span></span><br><span class="line">            and stuno =#&#123;stuno&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;classname != null and classname != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and classname like concat(&#x27;%&#x27;,#&#123;classname&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-Where标签"><a href="#5-2-Where标签" class="headerlink" title="5.2 Where标签"></a>5.2 <code>Where</code>标签</h3><p>用于处理<code>where</code>关键字和<code>and</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStuByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuno != null&quot;</span>&gt;</span></span><br><span class="line">            and stuno= #&#123;stuno&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;classname != null and classname != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and classname= #&#123;classname&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-Choose标签"><a href="#5-3-Choose标签" class="headerlink" title="5.3 Choose标签"></a>5.3 <code>Choose</code>标签</h3><p>前面的<code>when</code>条件成立  后面的  <code>when</code>就不再判断了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStuByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;stuno != null&quot;</span>&gt;</span></span><br><span class="line">                and stuno= #&#123;stuno&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;classname != null and classname != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and classname= #&#123;classname&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-Set标签"><a href="#5-4-Set标签" class="headerlink" title="5.4  Set标签"></a>5.4 <code> Set</code>标签</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStuByCondtion&quot;</span> &gt;</span></span><br><span class="line">    update student</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;classname != null and classname != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            , classname =#&#123;classname&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuno != null &quot;</span>&gt;</span></span><br><span class="line">            , stuname =#&#123;stuname&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where stuno =#&#123;stuno&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-5-Trim标签"><a href="#5-5-Trim标签" class="headerlink" title="5.5 Trim标签"></a>5.5 <code>Trim</code>标签</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStuByCondition&quot;</span> &gt;</span></span><br><span class="line">    update student</span><br><span class="line">    <span class="comment">&lt;!--prefix 要增加什么前缀</span></span><br><span class="line"><span class="comment">    prefixOverrides 要去除什么前缀</span></span><br><span class="line"><span class="comment">    suffix 要增加什么后缀</span></span><br><span class="line"><span class="comment">    suffixOverrides 要去除什么后缀</span></span><br><span class="line"><span class="comment">    set 是trim的一种特殊情况</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span>  <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuname != null and stuname != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            stuname= #&#123;stuname&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;classname != null and classname != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            classname= #&#123;classname&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where  stuno = #&#123;stuno&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-6-Bind标签"><a href="#5-6-Bind标签" class="headerlink" title="5.6 Bind标签"></a>5.6 <code>Bind</code>标签</h3><p>一般用于处理模糊查询的模板</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStuByClassName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;likePattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27;+param1+&#x27;%&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bind</span>&gt;</span></span><br><span class="line">    select * from student where classname like #&#123;classname&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6、缓存"><a href="#6、缓存" class="headerlink" title="6、缓存"></a>6、缓存</h2><h3 id="6-1-一级缓存"><a href="#6-1-一级缓存" class="headerlink" title="6.1 一级缓存"></a>6.1 一级缓存</h3><p>​一级存储是<code>SqlSession</code>上的缓存，默认开启，是一种内存型缓存,不要求实体类对象实现<code>Serializable</code>接口</p><p>​缓存中的数据使用键值对形式存储数据</p><p>​<code>namespace+sqlid+args+offset&gt;&gt;&gt; hash</code>值作为键,查询出的结果作为值</p><img src="/2022/06/04/study/MyBatis/sqlsession.png" class="" title="sqlsession一级缓存 image"><h3 id="6-2-二级缓存"><a href="#6-2-二级缓存" class="headerlink" title="6.2 二级缓存"></a>6.2 二级缓存</h3><p>​二级缓存是以<code>namespace</code>为标记的缓存，可以是由一个<code>SqlSessionFactory</code>创建的<code>SqlSession</code>之间共享缓存数据。默认并不开启，要求实体类必须实现序列化接口</p><img src="/2022/06/04/study/MyBatis/sqlsession2.png" class="" title="sqlsession二级缓存 image"><p>注意：</p><p>​1、<code> MyBatis</code>的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对<code>JavaBean</code>对象实现序列化接口。</p><p>​2、二级缓存是以 <code>namespace </code>为单位的，不同 <code>namespace</code> 下的操作互不影响</p><p>​3、加入<code>Cache</code>元素后，会对相应命名空间所有的<code>select</code>元素查询结果进行缓存，而其中的<code>insert</code>、<code>update</code>、<code>delete</code>在操作是会清空整个<code>namespace</code>的缓存</p><p>​4、<code>cache</code> 有一些可选的属性 <code>type</code>, <code>eviction</code>, <code>flushInterval</code>, <code>size</code>, <code>readOnly</code>, <code>blocking</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;&quot;</span> <span class="attr">eviction</span>=<span class="string">&quot;&quot;</span><span class="attr">flushInterval</span>=<span class="string">&quot;&quot;</span><span class="attr">size</span>=<span class="string">&quot;&quot;</span><span class="attr">blocking</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>type</td><td>自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口</td><td>null</td></tr><tr><td>readOnly</td><td>是否只读  <br />true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。<br />false:会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全</td><td>false</td></tr><tr><td>eviction</td><td>缓存策略<br />LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。<br />FIFO – 先进先出：按对象进入缓存的顺序来移除它们。<br />SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。<br />WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</td><td>LRU</td></tr><tr><td>flushInterval</td><td>刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，只有执行update、insert、delete语句才会刷新</td><td>null</td></tr><tr><td>size</td><td>缓存对象个数</td><td>1024</td></tr><tr><td>blocking</td><td>是否使用阻塞性缓存BlockingCache<br />true：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，否则会在查询数据库以后再释放锁，保证只有一个线程到数据库中查找指定key对应的数据<br />false：不使用阻塞性缓存，性能更好</td><td>false</td></tr></tbody></table><p>​5、如果在加入<code>Cache</code>元素的前提下让个别<code>select </code>元素不使用缓存，可以使用<code>useCache</code>属性，设置为<code>false</code>。**<code>useCache</code>**控制当前sql语句是否启用缓存  <code>flushCache</code>控制当前<code>sql</code>执行一次后是否刷新缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStuByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span> <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-3-三方缓存"><a href="#6-3-三方缓存" class="headerlink" title="6.3 三方缓存"></a>6.3 三方缓存</h3><ul><li>分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.<code>ehcache</code>,<code>redis </code>,<code>memcache</code>缓存框架。</li><li><code>Ehcache</code>：是一种广泛使用的开源<code>java</code>分布式缓存。主要面向通用缓存，<code>javaEE </code>和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式<code>web application</code>的</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;MyBatis学习&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="MyBatis" scheme="https://lyblog2022.github.io/categories/%E5%AD%A6%E4%B9%A0/MyBatis/"/>
    
    
    <category term="MyBatis" scheme="https://lyblog2022.github.io/tags/MyBatis/"/>
    
    <category term="学习" scheme="https://lyblog2022.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>518总结--post请求调用接口</title>
    <link href="https://lyblog2022.github.io/2022/05/18/dailysummary/20220518/dailysummary/"/>
    <id>https://lyblog2022.github.io/2022/05/18/dailysummary/20220518/dailysummary/</id>
    <published>2022-05-18T13:06:35.000Z</published>
    <updated>2022-06-04T15:25:27.560Z</updated>
    
    <content type="html"><![CDATA[<p>使用post方式调用接口并传递参数</p> <span id="more"></span><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.summary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.config.RequestConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.StringEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送post请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url：请求URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headerParamsJson：请求header参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramJson：请求参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">sendData</span><span class="params">(String url, JSONObject headerParamsJson, JSONObject paramJson)</span> &#123;</span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">resultJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送post请求</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">HttpPost</span> <span class="variable">httppost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line"><span class="type">RequestConfig</span> <span class="variable">defaultRequestConfig</span> <span class="operator">=</span> RequestConfig.custom().setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">.setConnectionRequestTimeout(<span class="number">5000</span>).setSocketTimeout(<span class="number">15000</span>).build();</span><br><span class="line">httppost.setConfig(defaultRequestConfig);</span><br><span class="line"><span class="type">StringEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(paramJson.toJSONString(), <span class="string">&quot;utf-8&quot;</span>);<span class="comment">// 解决中文乱码问题</span></span><br><span class="line">entity.setContentEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">entity.setContentType(<span class="string">&quot;text/json&quot;</span>);</span><br><span class="line">httppost.setEntity(entity);</span><br><span class="line">httppost.setHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加header参数</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">headerParamsIterator</span> <span class="operator">=</span> headerParamsJson.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (headerParamsIterator.hasNext()) &#123;</span><br><span class="line">Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) headerParamsIterator.next();</span><br><span class="line">httppost.setHeader(entry.getKey().toString(), entry.getValue().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装填参数</span></span><br><span class="line">List&lt;NameValuePair&gt; nvps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;NameValuePair&gt;();</span><br><span class="line"><span class="keyword">if</span> (paramJson != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> paramJson.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iterator.next();</span><br><span class="line">nvps.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>((String) entry.getKey(), (String) entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">UrlEncodedFormEntity</span> <span class="variable">reqEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlEncodedFormEntity</span>(nvps, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">httppost.setEntity(reqEntity);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行post请求.</span></span><br><span class="line"><span class="type">CloseableHttpClient</span> <span class="variable">httpclient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line"><span class="type">CloseableHttpResponse</span> <span class="variable">response1</span> <span class="operator">=</span> httpclient.execute(httppost);</span><br><span class="line"><span class="type">String</span> <span class="variable">resultText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> response1.getStatusLine().getStatusCode();</span><br><span class="line"><span class="keyword">if</span> (statusCode != <span class="number">200</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请求失败&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 响应实体</span></span><br><span class="line"><span class="type">HttpEntity</span> <span class="variable">entity2</span> <span class="operator">=</span> response1.getEntity();</span><br><span class="line"><span class="keyword">if</span> (entity2 != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 响应内容</span></span><br><span class="line">resultText = EntityUtils.toString(entity2, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">resultJson = JSONObject.parseObject(resultText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">resultJson.put(<span class="string">&quot;code&quot;</span>, statusCode);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">response1.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">resultJson.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;410&quot;</span>);</span><br><span class="line">resultJson.put(<span class="string">&quot;err&quot;</span>, e.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resultJson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用post方式调用接口并传递参数&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://lyblog2022.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    <category term="接口调用" scheme="https://lyblog2022.github.io/categories/%E6%80%BB%E7%BB%93/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
    
    
    <category term="接口调用" scheme="https://lyblog2022.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
</feed>
